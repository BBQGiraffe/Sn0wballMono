<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CodeStyle.Fixes</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServicesExtensions.GetExtendedLanguageServices(Microsoft.CodeAnalysis.Host.HostWorkspaceServices,System.String)">
            <summary>
            Gets extended host language services, which includes language services from <see cref="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetLanguageServices(System.String)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.FileExtensionsMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific file extensions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Language property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Languages property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.WorkspaceKindMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService">
            <summary>
            a service that provides a semantic model that will re-use last known compilation if
            semantic version hasn't changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Don't call this directly. use <see cref="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> (or an overload).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.LeftToken">
            <summary>
            The token to the left of <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.Position"/>. This token may be touching the position.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.TargetToken">
            <summary>
            The first token to the left of <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.Position"/> that we're not touching. Equal to <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.LeftToken"/>
            if we aren't touching <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.LeftToken" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.CreateGetHashCodeMethodStatements(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Boolean)">
            <summary>
            Generates an override of <see cref="M:System.Object.GetHashCode"/> similar to the one
            generated for anonymous types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.SimpleLocalDeclarationStatement(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            In VB it's more idiomatic to write things like <c>Dim t = TryCast(obj, SomeType)</c>
            instead of <c>Dim t As SomeType = TryCast(obj, SomeType)</c>, so we just elide the type
            from the decl.  For C# we don't want to do this though.  We want to always include the
            type and let the simplifier decide if it should be <c>var</c> or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.IsSpecialCaseBinaryExpression(Microsoft.CodeAnalysis.Operations.IBinaryOperation,Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)">
            <summary>
            Returns true if the binaryExpression consists of an expression that can never be negative, 
            such as length or unsigned numeric types, being compared to zero with greater than, 
            less than, or equals relational operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Attempts to return an speculative semantic model for <paramref name="document"/> if possible if <paramref
            name="position"/> is contained within a method body in the tree.  Specifically, this will attempt to get an
            existing cached semantic model for <paramref name="document"/>.  If it can find one, and the top-level semantic
            version for this project matches the cached version, and the position is within a method body, then it will 
            be returned, just with the previous corresponding method body swapped out with the current method body.
            <para/>
            If this is not possible, the regular semantic model for <paramref name="document"/> will be returned.
            <para/>
            When using this API, semantic model should only be used to ask questions about nodes inside of the member
            that contains the given <paramref name="position"/>.
            <para/>
            As a speculative semantic model may be returned, location based information provided by it may be innacurate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Attempts to return an speculative semantic model for <paramref name="document"/> if possible if <paramref
            name="span"/> is contained within a method body in the tree.  Specifically, this will attempt to get an
            existing cached semantic model <paramref name="document"/>.  If it can find one, and the top-level semantic
            version for this project matches the cached version, and the position is within a method body, then it will 
            be returned, just with the previous corresponding method body swapped out with the current method body.
            <para/>
            If this is not possible, the regular semantic model for <paramref name="document"/> will be returned.
            <para/>
            When using this API, semantic model should only be used to ask questions about nodes inside of the
            member that contains the given <paramref name="span"/>.
            <para/>
            As a speculative semantic model may be returned, location based information provided by it may be innacurate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Attempts to return an speculative semantic model for <paramref name="document"/> if possible if <paramref
            name="node"/> is contained within a method body in the tree.  Specifically, this will attempt to get an
            existing cached semantic model <paramref name="document"/>.  If it can find one, and the top-level semantic
            version for this project matches the cached version, and the position is within a method body, then it will 
            be returned, just with the previous corresponding method body swapped out with the current method body.
            <para/>
            If this is not possible, the regular semantic model for <paramref name="document"/> will be returned.
            <para/>
            When using this API, semantic model should only be used to ask questions about nodes inside of the
            member that contains the given <paramref name="node"/>.
            <para/>
            As a speculative semantic model may be returned, location based information provided by it may be innacurate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.VerifyNoErrorsAsync(Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken,System.Collections.Generic.List{System.String})">
            <summary>
            Debug only extension method to verify no errors were introduced by formatting, pretty listing and other related document altering service in error-free code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions.GetExtendedLanguageServices(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets extended host language services, which includes language services from <see cref="P:Microsoft.CodeAnalysis.Project.LanguageServices"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``1(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyMethodBodySemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within a method
            body then the document/semantic-model will be forked after each edit so that further
            edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyMethodBodySemanticEditsAsync``1(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within a method
            body then the document/semantic-model will be forked after each edit so that further
            edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplySemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Helper function for fix-all fixes where individual fixes may affect the viability
            of another.  For example, consider the following code:
            
                if ((double)x == (double)y)
                
            In this code either cast can be removed, but at least one cast must remain.  Even
            though an analyzer marks both, a fixer must not remove both.  One way to accomplish
            this would be to have the fixer do a semantic check after each application.  However
            This is extremely expensive, especially for hte common cases where one fix does
            not affect each other.
            
            To address that, this helper groups fixes at certain boundary points.  i.e. at 
            statement boundaries.  If there is only one fix within the boundary, it does not
            do any semantic verification.  However, if there are multiple fixes in a boundary
            it will call into <paramref name="canReplace"/> to validate if the subsequent fix
            can be made or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this text document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithAdditionalDocumentText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this additional document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this analyzer config document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IProgressTrackerExtensions.ItemCompletedScope(Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker,System.String)">
            <summary>
            Opens a scope that will call <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker.ItemCompleted"/> on <paramref name="tracker"/> once
            disposed. This is useful to easily wrap a series of operations and now that progress will be reported no
            matter how it completes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Transforms baseName into a name that does not conflict with any name in 'reservedNames'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Ensures that any 'names' is unique and does not collide with any other name.  Names that
            are marked as IsFixed can not be touched.  This does mean that if there are two names
            that are the same, and both are fixed that you will end up with non-unique names at the
            end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniquenessInPlace(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.String},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Updates the names in <paramref name="names"/> to be unique.  A name at a particular
            index <c>i</c> will not be touched if <c>isFixed[i]</c> is <see langword="true"/>. All
            other names will not collide with any other in <paramref name="names"/> and will all
            return <see langword="true"/> for <c>canUse(name)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImports.IAddImportsService.HasExistingImport(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxGenerator)">
            <summary>
            Returns true if the tree already has an existing import syntactically equivalent to
            <paramref name="import"/> in scope at <paramref name="contextLocation"/>.  This includes
            global imports for VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImports.IAddImportsService.GetImportContainer(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a context location in a provided syntax tree, returns the appropriate container
            that <paramref name="import"/> should be added to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory">
            <summary>
            Code fix category for code fixes provided by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.CodeStyle">
            <summary>
            Fixes code to adhere to code style.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.CodeQuality">
            <summary>
            Fixes code to improve code quality.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.Compile">
            <summary>
            Fixes code to fix compiler diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.Custom">
            <summary>
            Custom category for fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState.FixMultipleDiagnosticProvider">
            <summary>
            Diagnostic provider to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,System.String,System.Threading.CancellationToken)">
             <summary>
             Whether or not this diagnostic should be included when performing a FixAll.  This is
             useful for providers that create multiple diagnostics for the same issue (For example,
             one main diagnostic and multiple 'faded out code' diagnostics).  FixAll can be invoked
             from any of those, but we'll only want perform an edit for only one diagnostic for each
             of those sets of diagnostics.
            
             This overload differs from <see cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,System.String,System.Threading.CancellationToken)"/>
             in that it also passes along the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.
            
             This overload differs from <see cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic)"/> in
             that it also passes along the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState"/> in case that would be useful
             (for example if the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllState.CodeActionEquivalenceKey"/> is used.
            
             Only one of these three overloads needs to be overridden if you want to customize
             behavior.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic)">
             <summary>
             Whether or not this diagnostic should be included when performing a FixAll.  This is
             useful for providers that create multiple diagnostics for the same issue (For example,
             one main diagnostic and multiple 'faded out code' diagnostics).  FixAll can be invoked
             from any of those, but we'll only want perform an edit for only one diagnostic for each
             of those sets of diagnostics.
            
             By default, all diagnostics will be included in fix-all unless they are filtered out
             here. If only the diagnostic needs to be queried to make this determination, only this
             overload needs to be overridden.  However, if information from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState"/>
             is needed (for example <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllState.CodeActionEquivalenceKey"/>), then <see
             cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,System.String,System.Threading.CancellationToken)"/>
             should be overridden instead.
            
             Only one of these two overloads needs to be overridden if you want to customize
             behavior.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService.CanMoveDeclarationNearReferenceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Returns true if <paramref name="localDeclarationStatement"/> is local declaration statement
            that can be moved forward to be closer to its first reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService.MoveDeclarationNearReferenceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Moves <paramref name="localDeclarationStatement"/> closer to its first reference. Only
            applicable if <see cref="M:Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService.CanMoveDeclarationNearReferenceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> returned
            <code>true</code>.  If not, then the original document will be returned unchanged.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService.ReplaceAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the
            local declarations named '_' replaced with simple assignments to discard.
            For example,
             1. <code>int _ = M();</code> is replaced with <code>_ = M();</code>
             2. <code>int x = 1, _ = M(), y = 2;</code> is replaced with following statements:
             <code>
                     int x = 1;
                     _ = M();
                     int y = 2;
             </code>
            This is normally done in context of a code transformation that generates new discard assignment(s),
            such as <code>_ = M();</code>, and wants to prevent compiler errors where the containing method already
            has a discard variable declaration, say <code>var _ = M2();</code> at some line after the one
            where the code transformation wants to generate new discard assignment(s), which would be a compiler error.
            This method replaces such discard variable declarations with discard assignments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKindsService">
            <summary>
            Provides a uniform view of SyntaxKinds over C# and VB for constructs they have
            in common.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService">
            <summary>
            Helper service for telling you what type can be inferred to be viable in a particular
            location in code.  This is useful for features that are starting from code that doesn't bind,
            but would like to know type that code should be in the location that it can be found in.  For
            example:
            
              int i = Here(); 
            
            If 'Here()' doesn't bind, then this class can be used to say that it is currently in a
            location whose type has been inferred to be 'int' from the surrounding context.  Note: this
            is simply a best effort guess.  'byte/short/etc.' as well as any user convertible types to
            int would also be valid here, however 'int' seems the most reasonable when considering user
            intuition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSemanticFactsService.GetCollidableSymbols(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Retrieves all symbols that could collide with a symbol at the specified location.
            A symbol can possibly collide with the location if it is available to that location and/or
            could cause a compiler error if its name is re-used at that location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Given a symbol in source, returns the syntax nodes that compromise its declarations.
            This differs from symbol.Locations in that Locations returns a list of ILocations that
            normally correspond to the name node of the symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal">
            <summary>
            Internal extensions to <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/>.
            
            This interface is available in the shared CodeStyle and Workspaces layer to allow
            sharing internal generator methods between them. Once the methods are ready to be
            made public APIs, they can be moved to <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Creates a statement that declares a single local variable with an optional initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.AddParentheses(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Wraps with parens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.YieldReturnStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to yield a value from an iterator method.
            </summary>
            <param name="expression">An expression that can be yielded.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.RequiresLocalDeclarationType">
            <summary>
            <see langword="true"/> if the language requires a "TypeExpression"
            (including <see langword="var"/>) to be stated when making a 
            <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)"/>.
            <see langword="false"/> if the language allows the type node to be entirely elided.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.AbstractLogAggregator`1">
            <summary>
            helper class to aggregate some numeric value log in client side
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Maximum">
            <summary>
            maximum value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Minimum">
            <summary>
            minimum value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Median">
            <summary>
            middle value of the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Mean">
            <summary>
            average value of the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Mode">
            <summary>
            most frequent value in the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Range">
            <summary>
            difference between max and min value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Count">
            <summary>
            number of data points in the total data set
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation">
            <summary>
            This annotation will be used by rename to mark all places where it needs to rename an identifier (token replacement) and where to 
            check if the semantics have been changes (conflict detection).
            </summary>
            <remarks>This annotation should be put on tokens only.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.OriginalSpan">
            <summary>
            The span this token occupied in the original syntax tree. Can be used to show e.g. conflicts in the UI.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsRenameLocation">
            <summary>
            A flag indicating whether this is a location that needs to be renamed or just tracked for conflicts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsOriginalTextLocation">
            <summary>
            A flag indicating whether the token at this location has the same ValueText then the original name 
            of the symbol that gets renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Prefix">
            <summary>
            When replacing the annotated token this string will be prepended to the token's value. This is used when renaming compiler 
            generated fields and methods backing properties (e.g. "get_X" or "_X" for property "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Suffix">
            <summary>
            When replacing the annotated token this string will be appended to the token's value. This is used when renaming compiler 
            generated types whose names are derived from user given names (e.g. "XEventHandler" for event "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.RenameDeclarationLocationReferences">
            <summary>
            A single dimensional array of annotations to verify after rename.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsNamespaceDeclarationReference">
            <summary>
            States if this token is a Namespace Declaration Reference
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsMemberGroupReference">
            <summary>
            States if this token is a member group reference, typically found in NameOf expressions
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsInvocationExpression">
            <summary>
            States if this token is annotated as a part of the Invocation Expression that needs to be checked for the Conflicts
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference">
            <summary>
            This class is used to refer to a Symbol definition which could be in source or metadata
            it has a metadata name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.Name">
            <summary>
            The metadata name for this symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.SymbolLocationsCount">
            <summary>
            Count of symbol location (Partial Types, Constructors, etc).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.IsOverriddenFromMetadata">
            <summary>
            A flag indicating that the associated symbol is an override of a symbol from metadata
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider.ConvertTypeOfToNameOf(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode)">
            <Summary>
             Method converts typeof(...).Name to nameof(...)
            </Summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1.AdjustAndAddAppropriateDeclaratorsToRemove(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            This method adjusts the <paramref name="declarators"/> to remove based on whether or not all variable declarators
            within a field declaration should be removed,
            i.e. if all the fields declared within a field declaration are unused,
            we can remove the entire field declaration instead of individual variable declarators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1.AdjustAndAddAppropriateDeclaratorsToRemove(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            If all the <paramref name="childDeclarators"/> are contained in <paramref name="declarators"/>,
            the removes the <paramref name="childDeclarators"/> from <paramref name="declarators"/>, and
            adds the <paramref name="parentDeclaration"/> to the <paramref name="declarators"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11">
            <summary>
            Code fixer for unused expression value diagnostics reported by <see cref="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer"/>.
            We provide following code fixes:
                1. If the unused value assigned to a local/parameter has no side-effects,
                   we recommend removing the assignment. We consider an expression value to have no side effects
                   if one of the following is true:
                    1. Value is a compile time constant.
                    2. Value is a local or parameter reference.
                    3. Value is a field reference with no or implicit this instance.
                2. Otherwise, if user preference is set to DiscardVariable, and project's
                   language version supports discard variable, we recommend assigning the value to discard.
                3. Otherwise, we recommend assigning the value to a new unused local variable which has no reads.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Method to update the identifier token for the local/parameter declaration or reference
            that was flagged as an unused value write by the analyzer.
            Returns null if the provided node is not one of the handled node kinds.
            Otherwise, returns the new node with updated identifier.
            </summary>
            <param name="node">Flaggged node containing the identifier token to be replaced.</param>
            <param name="newName">New identifier token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetForEachStatementIdentifier(`6)">
            <summary>
            Gets the identifier token for the iteration variable of the given foreach statement node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.WrapWithBlockIfNecessary(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Wraps the given statements within a block statement.
            Note this method is invoked when replacing a statement that is parented by a non-block statement syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(`7,Microsoft.CodeAnalysis.Editing.SyntaxEditor,`4)">
            <summary>
            Inserts the given declaration statement at the start of the given switch case block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetReplacementNodeForCompoundAssignment(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Gets the replacement node for a compound assignment expression whose
            assigned value is redundant.
            For example, "x += MethodCall()", where assignment to 'x' is redundant
            is replaced with "_ = MethodCall()" or "var unused = MethodCall()"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateParentOfUpdatedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts)">
            <summary>
            Rewrite the parent of a node which was rewritted by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.
            </summary>
            <param name="parent">The original parent of the node rewritten by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.</param>
            <param name="newNameNode">The rewritten node produced by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.</param>
            <param name="editor">The syntax editor for the code fix.</param>
            <param name="syntaxFacts">The syntax facts for the current language.</param>
            <returns>The replacement node to use in the rewritten syntax tree; otherwise, <see langword="null"/> to only
            rewrite the node originally rewritten by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.NeedsToMoveNewLocalDeclarationsNearReference(System.String)">
            <summary>
            Flag to indicate if the code fix can introduce local declaration statements
            that need to be moved closer to the first reference of the declared variable.
            This is currently only possible for the unused value assignment fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.ReplaceDiscardDeclarationsWithAssignmentsAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the
            local declarations named '_' converted to simple assignments to discard.
            For example, <code>int _ = Computation();</code> is converted to
            <code>_ = Computation();</code>.
            This is needed to prevent the code fix/FixAll from generating code with
            multiple local variables named '_', which is a compiler error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.AdjustLocalDeclarationsAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the new
            local declaration statements annotated with <see cref="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.s_newLocalDeclarationStatementAnnotation"/>
            moved closer to first reference and all the existing
            local declaration statements annotated with <see cref="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.s_existingLocalDeclarationWithoutInitializerAnnotation"/>
            whose declared local is no longer used removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4.CreateConditionalExpressionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Operations.IConditionalOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Helper to create a conditional expression out of two original IOperation values
            corresponding to the whenTrue and whenFalse parts. The helper will add the appropriate
            annotations and casts to ensure that the conditional expression preserves semantics, but
            is also properly simplified and formatted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4.MakeMultiLineAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Checks if we should wrap the conditional expression over multiple lines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6.FixOneAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Threading.CancellationToken)">
            <summary>
            Returns 'true' if a multi-line conditional was created, and thus should be
            formatted specially.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleFixesResources.EmptyResource">
            <summary>Remove this value when another is added.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Supplied_diagnostic_cannot_be_null">
            <summary>Supplied diagnostic cannot be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0">
            <summary>Fix all '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0_in_1">
            <summary>Fix all '{0}' in '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0_in_Solution">
            <summary>Fix all '{0}' in Solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0">
            <summary>Compilation is required to accomplish the task but is not supported by project {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0">
            <summary>Syntax tree is required to accomplish the task but is not supported by document {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution">
            <summary>Project of ID {0} is required to accomplish the task but is not available from the solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.The_solution_does_not_contain_the_specified_document">
            <summary>The solution does not contain the specified document.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Warning_colon_Declaration_changes_scope_and_may_change_meaning">
            <summary>Warning: Declaration changes scope and may change meaning.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_file_header">
            <summary>Add file header</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Fix_Name_Violation_colon_0">
            <summary>Fix Name Violation: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_both">
            <summary>Add both</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_default_case">
            <summary>Add default case</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Use_discarded_local">
            <summary>Use discarded local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Use_discard_underscore">
            <summary>Use discard '_'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Remove_redundant_assignment">
            <summary>Remove redundant assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Update_suppression_format">
            <summary>Update suppression format</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Suppress_or_Configure_issues">
            <summary>Suppress or Configure issues</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Fix_all_occurrences_in">
            <summary>Fix all occurrences in</summary>
        </member>
    </members>
</doc>
