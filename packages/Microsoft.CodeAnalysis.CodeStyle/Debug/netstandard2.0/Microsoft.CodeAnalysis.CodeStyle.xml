<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CodeStyle</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers.TryGetCodeStyleValue(System.String,System.String@)">
            <summary>
            Given an editor-config code-style-option, gives back the core value part of the 
            option.  For example, if the option is "true:error" or "true" then "true" will be returned
            in <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers.TryGetCodeStyleValueAndOptionalNotification(System.String,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,System.String@,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2@)">
            <summary>
            Given an editor-config code-style-option, gives back the constituent parts of the 
            option.  For example, if the option is "true:error" then "true" will be returned
            in <paramref name="value"/> and <see cref="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Error"/> will be returned
            in <paramref name="notification"/>.  Note that users are allowed to not provide
            a NotificationOption, so <paramref name="notification"/> will default to <paramref name="defaultNotification"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1">
            <summary>
            Represents a code style option and an associated notification option.  Supports
            being instantiated with T as a <see cref="T:System.Boolean"/> or an <c>enum type</c>.
            
            CodeStyleOption also has some basic support for migration a <see cref="T:System.Boolean"/> option
            forward to an <c>enum type</c> option.  Specifically, if a previously serialized
            bool-CodeStyleOption is then deserialized into an enum-CodeStyleOption then 'false' 
            values will be migrated to have the 0-value of the enum, and 'true' values will be
            migrated to have the 1-value of the enum.
            
            Similarly, enum-type code options will serialize out in a way that is compatible with 
            hosts that expect the value to be a boolean.  Specifically, if the enum value is 0 or 1
            then those values will write back as false/true.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.TrueWithSilentEnforcement">
            <remarks>
            When user preferences are not yet set for a style, we fall back to the default value.
            One such default(s), is that the feature is turned on, so that codegen consumes it,
            but with silent enforcement, so that the user is not prompted about their usage.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyFieldAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in field access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyPropertyAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in property access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyMethodAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in method access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyEventAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in event access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.PreferIntrinsicPredefinedTypeKeywordInDeclaration">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Declarations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.PreferIntrinsicPredefinedTypeKeywordInMemberAccess">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Member Access Expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference">
            <remarks>
            Note: the order of this enum is important.  We originally only supported two values,
            and we encoded this as a bool with 'true = WhenPossible' and 'false = never'.  To
            preserve compatibility we map the false value to 0 and the true value to 1.  All new
            values go after these. 
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2">
            <summary>
            Offers different notification styles for enforcing
            a code style. Under the hood, it simply maps to <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/>
            </summary>
            <remarks>
            This also supports various properties for databinding.
            </remarks>
            <completionlist cref="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Name">
            <summary>
            Name for the notification option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Severity">
            <summary>
            Diagnostic severity associated with notification option.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.None">
            <summary>
            Notification option to disable or suppress an option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Suppress"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Silent">
            <summary>
            Notification option for a silent or hidden option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Hidden"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Suggestion">
            <summary>
            Notification option for a suggestion or an info option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Info"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Warning">
            <summary>
            Notification option for a warning option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Warn"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Error">
            <summary>
            Notification option for an error option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Error"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.UnusedParametersPreference">
            <summary>
            Preferences for flagging unused parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference">
            <summary>
            Assignment preference for unused values from expression statements and assignments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,Microsoft.CodeAnalysis.Options.IPerLanguageOption,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            unique <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption"/> code style option.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="option">
            Per-language option that can be used to configure the given <paramref name="diagnosticId"/>.
            <see langword="null"/>, if there is no such unique option.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            <see langword="null"/> if the message is identical to the title.
            </param>
            <param name="isUnnecessary"><see langword="true"/> if the diagnostic is reported on unnecessary code; otherwise, <see langword="false"/>.</param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,Microsoft.CodeAnalysis.Options.ILanguageSpecificOption,System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            unique <see cref="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption"/> code style option for the given language.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="option">
            Language specific option that can be used to configure the given <paramref name="diagnosticId"/>.
            <see langword="null"/>, if there is no such unique option.
            </param>
            <param name="language">Language for the given language-specific <paramref name="option"/>.</param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            <see langword="null"/> if the message is identical to the title.
            </param>
            <param name="isUnnecessary"><see langword="true"/> if the diagnostic is reported on unnecessary code; otherwise, <see langword="false"/>.</param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.IPerLanguageOption},Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            two or more <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption"/> code style options.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="options">
            Set of two or more per-language options that can be used to configure the diagnostic severity of the given diagnosticId.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            Null if the message is identical to the title.
            </param>
            <param name="isUnnecessary"><see langword="true"/> if the diagnostic is reported on unnecessary code; otherwise, <see langword="false"/>.</param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.ILanguageSpecificOption},System.String,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            two or more <see cref="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption"/> code style options for the given language.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="options">
            Set of two or more language-specific options that can be used to configure the diagnostic severity of the given diagnosticId.
            </param>
            <param name="language">Language for the given language-specific <paramref name="options"/>.</param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            Null if the message is identical to the title.
            </param>
            <param name="isUnnecessary"><see langword="true"/> if the diagnostic is reported on unnecessary code; otherwise, <see langword="false"/>.</param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.IPerLanguageOption})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with per-language options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.ILanguageSpecificOption},System.String)">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with language-specific options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.ILanguageSpecificOption},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.IPerLanguageOption},System.String)">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with a mix of language-specific and per-language options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DiagnosticDescriptor})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors such that all the descriptors have no unique code style option to configure the descriptors.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild">
            <summary>
            Build enforcement recommendation for a code style analyzer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.Never">
            <summary>
            Indicates that the code style diagnostic is an IDE-only diagnostic that cannot be enforced on build.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.WhenExplicitlyEnabled">
            <summary>
            Indicates that the code style diagnostic can be enforced on build when explicitly enabled in a configuration file,
            but is not part of the <see cref="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.Recommended"/> or <see cref="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.HighlyRecommended"/> group for build enforcement.
            <para>This is the suggested <b>P3</b> bucket of code style diagnostics to enforce on build.</para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.Recommended">
            <summary>
            Indicates that the code style diagnostic can be enforced on build and is part of the recommended group for build enforcement.
            <para>This is the suggested <b>P2</b> bucket of code style diagnostics to enforce on build.</para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.HighlyRecommended">
            <summary>
            Indicates that the code style diagnostic can be enforced on build and is part of the highly recommended group for build enforcement.
            <para>This is the suggested <b>P1</b> bucket of code style diagnostics to enforce on build.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyleSyntaxNodeExtensions.FirstAncestorOrSelf``2(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,``1,System.Boolean},``1,System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
            <remarks>
            This method was added to <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> as a public API. This extension method can be removed once
            the code style layer is updated to reference a version of Roslyn that includes it. It will be easy to
            identify since this method will show 0 references once the switch occurs.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormatterHelper">
            <summary>
            Formats whitespace in documents or syntax trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormatterHelper.GetDefaultFormattingRules(Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService)">
            <summary>
            Gets the formatting rules that would be applied if left unspecified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormatterHelper.FormatAsync(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in an area of a document corresponding to a text span.
            </summary>
            <param name="syntaxTree">The document to format.</param>
            <param name="span">The span of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormatterHelper.FormatAsync(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to multiple non-overlapping spans.
            </summary>
            <param name="syntaxTree">The document to format.</param>
            <param name="spans">The spans of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormatterHelper.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormatterHelper.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree.</param>
            <param name="annotation">The descendant nodes of the root to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormatterHelper.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.ContextIntervalTree`2">
            <summary>
            a tweaked version of our interval tree to meet the formatting engine's need
            
            it now has an ability to return a smallest span that contains a position rather than
            all Intersecting or overlapping spans
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext">
            <summary>
            this class maintain contextual information such as 
            indentation of current position, based token to follow in current position and etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData">
            <summary>
            data that will be used in an interval tree related to Anchor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData">
            <summary>
            data that will be used in an interval tree related to indentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressSpacingData">
            <summary>
            data that will be used in an interval tree related to suppressing spacing operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressWrappingData">
            <summary>
            data that will be used in an interval tree related to suppressing wrapping operations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult.Rewriter(System.Collections.Generic.Dictionary{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the node with the given trivia information in the map
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.FormatSummary">
            <summary>
            return summary for current formatting work
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.OperationApplier">
            <summary>
            this actually applies formatting operations to trivia between two tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.FormattedSpan">
            <summary>
            span in the tree to format
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.Rewriter(System.Collections.Generic.Dictionary{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the tree info root node with the trivia information in the map
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory.Whitespace">
            <summary>
            represents a general trivia between two tokens. slightly more expensive than others since it
            needs to calculate stuff unlike other cases
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.NodeOperations">
            <summary>
            this collector gathers formatting operations that are based on a node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenData">
            <summary>
            it represents a token that is inside of token stream not also outside of token stream
            
            it uses an index to navigate previous and after tokens in the stream to make navigation faster. and regular
            Previous/NextToken for tokens outside of the stream.
            
            this object is supposed to be live very short but created a lot of time. that is why it is struct. 
            (same reason why SyntaxToken is struct - to reduce heap allocation)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations">
            <summary>
            it holds onto space and wrapping operation need to run between two tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream">
            <summary>
            This class takes care of tokens consumed in the formatting engine.
            
            It will maintain information changed compared to original token information. and answers
            information about tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream.Changes">
            <summary>
            Thread-safe collection that holds onto changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.TokenStream.GetColumn(Microsoft.CodeAnalysis.Formatting.TokenData,System.Func{Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TriviaData})">
            <summary>
            Get column of the token 
            * column means text position on a line where all tabs are converted to spaces that first position on a line becomes 0
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TreeData">
            <summary>
            this provides information about the syntax tree formatting service is formatting.
            this provides necessary abstraction between different kinds of syntax trees so that ones that contain
            actual text or cache can answer queries more efficiently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TriviaData">
            <summary>
            it holds onto trivia information between two tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds.FormattingDiagnosticId">
            <summary>
            This is the ID reported for formatting diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds.FormatDocumentControlDiagnosticId">
            <summary>
            This special diagnostic can be suppressed via <c>#pragma</c> to prevent the formatter from making changes to
            code formatting within the span where the diagnostic is suppressed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.PreferredWrappingColumn">
            <summary>
            Default value of 120 was picked based on the amount of code in a github.com diff at 1080p.
            That resolution is the most common value as per the last DevDiv survey as well as the latest
            Steam hardware survey.  This also seems to a reasonable length default in that shorter
            lengths can often feel too cramped for .NET languages, which are often starting with a
            default indentation of at least 16 (for namespace, class, member, plus the final construct
            indentation).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.IFormattingResult">
            <summary>
            Contains changes that can be either applied to different targets such as a buffer or a tree
            or examined to be used in other places such as quick fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule">
            <summary>
            Provide a custom formatting operation provider that can intercept/filter/replace default formatting operations.
            </summary>
            <remarks>All methods defined in this class can be called concurrently. Must be thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddSuppressOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddAnchorIndentationOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddIndentBlockOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddAlignTokensOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.GetAdjustNewLinesOperation(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.GetAdjustSpacesOperation(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddSuppressOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddAnchorIndentationOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddIndentBlockOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddAlignTokensOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.GetAdjustNewLinesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.GetAdjustSpacesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation">
            <summary>
            indicate how many lines are needed between two tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption">
             <summary>
             Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation"/>.
            
             <list type="bullet">
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption.PreserveLines"/></term>
                 <description>the operation will leave lineBreaks as it is if original lineBreaks are equal or greater than given lineBreaks</description>
               </item>
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption.ForceLines"/></term>
                 <description>the operation will force existing lineBreaks to the given lineBreaks</description>
               </item>
             </list>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation">
            <summary>
            indicate how many spaces are needed between two spaces
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption">
            <summary>
            Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.PreserveSpaces">
            <summary>
            Preserve spaces as it is
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DefaultSpacesIfOnSingleLine">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DefaultSpacesIfOnSingleLine"/> means a default space operation created by the formatting
            engine by itself. It has its own option kind to indicates that this is an operation
            generated by the engine itself. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpacesIfOnSingleLine">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpacesIfOnSingleLine"/> means forcing the specified spaces between two tokens if two
            tokens are on a single line. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpaces">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpaces"/> means forcing the specified spaces regardless of positions of two tokens.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DynamicSpaceToIndentationIfOnSingleLine">
            <summary>
            If two tokens are on a single line, second token will be placed at current indentation if possible
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation">
            <summary>
            align first tokens on lines among the given tokens to the base token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption">
            <summary>
            option to control <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation"/> behavior
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation">
            <summary>
            preserve relative spaces between anchor token and first tokens on lines within the given text span 
            as long as it doesn't have explicit line operations associated with them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            create anchor indentation region around start and end token
            start token will act as anchor token and right after anchor token to end of end token will become anchor region
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            create anchor indentation region more explicitly by providing all necessary information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around start and end token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around the given text span
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAlignTokensOperation(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption)">
            <summary>
            instruct the engine to try to align first tokens on the lines among the given tokens to be aligned to the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustNewLinesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption)">
            <summary>
            instruct the engine to try to put the give lines between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustSpacesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption)">
            <summary>
            instruct the engine to try to put the given spaces between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetSuppressOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            return SuppressOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAnchorIndentationOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            return AnchorIndentationOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetIndentBlockOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            return IndentBlockOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAlignTokensOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            return AlignTokensOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustNewLinesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            return AdjustNewLinesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustSpacesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            return AdjustSpacesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation">
            <summary>
            set indentation level for the given text span. it can be relative, absolute or dependent to other tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption">
            <summary>
            Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine">
            <summary>
            This indentation will be a delta to the first token in the line in which the base token is present
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePosition">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation.IndentationDeltaOrPosition"/> will be interpreted as delta of its enclosing indentation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.AbsolutePosition">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation.IndentationDeltaOrPosition"/> will be interpreted as absolute position
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePositionMask">
            <summary>
            Mask for relative position options
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.PositionMask">
            <summary>
            Mask for position options.
            </summary>
            <remarks>
            Each <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation"/> specifies one of the position options to indicate the primary
            behavior for the operation.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.IndentIfConditionOfAnchorToken">
            <summary>
            Increase the <see cref="P:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation.IndentationDeltaOrPosition"/> if the block is part of a
            condition of the anchor token. For example:
            
            <code>
            if (value is
                { // This open brace token is part of a condition of the 'if' token.
                    Length: 2
                })
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation">
            <summary>
            suppress formatting operations within the given text span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption">
             <summary>
             Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation"/>.
            
             <list type="bullet">
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.NoWrappingIfOnSingleLine"/></term>
                 <description>no wrapping if given tokens are on same line</description>
               </item>
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.NoWrapping"/></term>
                 <description>no wrapping regardless of relative positions of two tokens</description>
               </item>
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.NoSpacing"/></term>
                 <description>no spacing regardless of relative positions of two tokens</description>
               </item>
             </list>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.DisableFormatting">
            <summary>
            Completely disable formatting within a span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.#cctor">
            <summary>
            set up space string caches
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Formatter`1">
            <summary>
            format the trivia at the line column and put changes to the changes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.WhitespaceAppender`1">
            <summary>
            create whitespace for the delta at the line column and put changes to the changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Succeeded">
            <summary>
            return whether this formatting succeeded or not
            for example, if there is skipped tokens in one of trivia between tokens
            we consider formatting this region is failed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsWhitespace(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is whitespace trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsEndOfLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is end of line trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsNullOrWhitespace(System.String)">
            <summary>
            check whether given string is either null or whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsWhitespace(System.Char)">
            <summary>
            check whether given char is whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsNewLine(System.Char)">
            <summary>
            check whether given char is new line char
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.CreateWhitespace(System.String)">
            <summary>
            create whitespace trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.CreateEndOfLine">
            <summary>
            create end of line trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,System.Boolean,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            return line column rule for the given two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxTrivia},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put text change result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.ContainsImplicitLineBreak(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            returns true if the trivia contains a Line break
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetOverallLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,System.Boolean,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            get line column rule between two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetTokensAtEdgeOfStructureTrivia(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            if the given trivia is the very first or the last trivia between two normal tokens and 
            if the trivia is structured trivia, get one token that belongs to the structured trivia and one belongs to the normal token stream
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.ContainsOnlyWhitespace(System.Int32,System.Int32)">
            <summary>
            check whether string between start and end position only contains whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.FirstLineBlank">
            <summary>
            check whether first line between two tokens contains only whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetTrailingLinesAtEndOfTrivia1(Microsoft.CodeAnalysis.Formatting.LineColumn)">
            <summary>
            return 0 or 1 based on line column of the trivia1's end point
            this is based on our structured trivia's implementation detail that some structured trivia can have
            one new line at the end of the trivia
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumn.Line">
            <summary>
            absolute line number from first token
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumn.Column">
            <summary>
            absolute column from beginning of a line
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumn.WhitespaceOnly">
            <summary>
            there is only whitespace on this line
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.Lines">
            <summary>
            relative line number between calls
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.Spaces">
            <summary>
            relative spaces between calls
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.WhitespaceOnly">
            <summary>
            there is only whitespace in this space
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.ForceUpdate">
            <summary>
            force text change regardless line and space changes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IPragmaSuppressionsAnalyzer">
            <summary>
            Special IDE analyzer to flag unnecessary inline source suppressions,
            i.e. pragma and local SuppressMessageAttribute suppressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IPragmaSuppressionsAnalyzer.AnalyzeAsync(Microsoft.CodeAnalysis.SemanticModel,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DiagnosticDescriptor}},System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Analyzes the tree, with an optional span scope, and report unnecessary inline suppressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSeverityExtensions.ToReportDiagnostic(Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Returns the equivalent <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> for a <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.
            </summary>
            <param name="diagnosticSeverity">The <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.</param>
            <returns>
            The equivalent <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> for the <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <paramref name="diagnosticSeverity"/> is not one of the expected values.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ReportDiagnosticExtensions.ToDiagnosticSeverity(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Returns the equivalent <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> for a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.
            </summary>
            <param name="reportDiagnostic">The <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.</param>
            <returns>
            The equivalent <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> for a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value; otherwise,
            <see langword="null"/> if <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> does not contain a direct equivalent for
            <paramref name="reportDiagnostic"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <paramref name="reportDiagnostic"/> is not one of the expected values.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ReportDiagnosticExtensions.WithDefaultSeverity(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Applies a default severity to a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.
            </summary>
            <param name="reportDiagnostic">The <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.</param>
            <param name="defaultSeverity">The default severity.</param>
            <returns>
            <para>If <paramref name="reportDiagnostic"/> is <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Default"/>, returns
            <paramref name="defaultSeverity"/>.</para>
            <para>-or-</para>
            <para>Otherwise, returns <paramref name="reportDiagnostic"/> if it has a non-default value.</para>
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.PascalCase">
            <summary>
            Each word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.CamelCase">
            <summary>
            Every word except the first word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.FirstUpper">
            <summary>
            Only the first word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.AllUpper">
            <summary>
            Every character is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.AllLower">
            <summary>
            No characters are capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser._cache">
            <remarks>
            The dictionary we get from the VS editorconfig API uses the same dictionary object if there are no changes, so we can cache based on dictionary
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser.NamingRuleSubsetComparer.FirstIsSubset(Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule@,Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule@)">
            <summary>
            Determines if <paramref name="x"/> matches a subset of the symbols matched by <paramref name="y"/>. The
            implementation determines which properties of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule"/> are considered for this
            evaluation. The subset relation does not necessarily indicate a proper subset.
            </summary>
            <param name="x">The first naming rule.</param>
            <param name="y">The second naming rule.</param>
            <returns><see langword="true"/> if <paramref name="x"/> matches a subset of the symbols matched by
            <paramref name="y"/> on some implementation-defined properties; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleRules.IsInterfaceImplementation(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            This does not handle the case where a method in a base type implicitly implements an
            interface method on behalf of one of its derived types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences">
            <summary>
            Contains all information related to Naming Style Preferences.
            1. Symbol Specifications
            2. Name Style
            3. Naming Rule (points to Symbol Specification IDs)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.None">
            <summary>
            Invalid value, analyzer must support at least one or more of the subsequent analysis categories.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SyntaxTreeWithoutSemanticsAnalysis">
            <summary>
            Analyzer reports syntax diagnostics (i.e. registers a SyntaxTree action).
            Note: an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> that uses this will not work properly if
            it registers a <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])"/> and then ends
            up needing to use the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.SemanticModel"/>.  If a
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> is needed, use <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticSpanAnalysis"/> or
            <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticDocumentAnalysis"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticSpanAnalysis">
            <summary>
            Analyzer reports semantic diagnostics and also supports incremental span based method body analysis.
            An analyzer can support incremental method body analysis if edits within a method body only affect the diagnostics reported by the analyzer on the edited method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticDocumentAnalysis">
            <summary>
            Analyzer reports semantic diagnostics but doesn't support incremental span based method body analysis.
            It needs to re-analyze the whole document for reporting semantic diagnostics even for method body editing scenarios.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.ProjectAnalysis">
            <summary>
            Analyzer reports project diagnostics (i.e. registers a Compilation action and/or Compilation end action diagnostics).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer">
            <summary>
            This interface is a marker for all the analyzers that are built in.
            We will record non-fatal-watson if any analyzer with this interface throws an exception.
            
            also, built in analyzer can do things that third-party analyzer (command line analyzer) can't do
            such as reporting all diagnostic descriptors as hidden when it can return different severity on runtime.
            
            or reporting diagnostics ID that is not reported by SupportedDiagnostics.
            
            this interface is used by the engine to allow this special behavior over command line analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer.GetAnalyzerCategory">
            <summary>
            This category will be used to run analyzer more efficiently by restricting scope of analysis
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer.OpenFileOnly(Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            This indicates whether this built-in analyzer will only run on opened files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithLocationTags(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Object[])">
            <summary>
            Create a diagnostic that adds properties specifying a tag for a set of locations.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            These locations are joined with <paramref name="additionalUnnecessaryLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="additionalUnnecessaryLocations">
            An optional set of additional locations indicating unnecessary code related to the diagnostic.
            These locations are joined with <paramref name="additionalLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithLocationTags(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Create a diagnostic that adds properties specifying a tag for a set of locations.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            These locations are joined with <paramref name="additionalUnnecessaryLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="additionalUnnecessaryLocations">
            An optional set of additional locations indicating unnecessary code related to the diagnostic.
            These locations are joined with <paramref name="additionalLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithLocationTags(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{System.Int32}},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Create a diagnostic that adds properties specifying a tag for a set of locations.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            </param>
            <param name="tagIndices">
            a map of location tag to index in additional locations.
            "AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer" for an example of usage.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithMessage(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},Microsoft.CodeAnalysis.LocalizableString)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="effectiveSeverity">Effective severity of the diagnostic.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="message">Localizable message for the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds.FileHeaderMismatch">
            <summary>
            Reported when a file header is missing or does not match the expected string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIdToOptionMappingHelper">
            <summary>
            Helper type to map <see cref="T:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds"/> to an unique editorconfig code style option, if any,
            such that diagnostic's severity can be configured in .editorconfig with an entry such as:
                "%option_name% = %option_value%:%severity%
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState.TargetSymbolResolver.Resolve(System.Boolean@)">
            <summary>
            Attempts to resolve the "Target" argument of the global SuppressMessageAttribute to symbols in compilation.
            </summary>
            <param name="resolvedWithDocCommentIdFormat">Indicates if resolved "Target" argument is in Roslyn's <see cref="T:Microsoft.CodeAnalysis.DocumentationCommentId"/> format.</param>
            <returns>Resolved symbols for the the "Target" argument of the global SuppressMessageAttribute.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock">
            <summary>
            no op log block
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.FunctionId">
            <summary>
            Enum to uniquely identify each function location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.ILogger">
            <summary>
            logger interface actual logger should implements
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.IsEnabled(Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            answer whether it is enabled or not for the specific function id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage)">
            <summary>
            log a specific event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlockStart(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log a start event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlockEnd(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log an end event
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger">
            <summary>
            provide a way to log activities to various back end such as etl, code marker and etc
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.Logger.s_lastUniqueBlockId">
            <summary>
            next unique block id that will be given to each LogBlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.SetLogger(Microsoft.CodeAnalysis.Internal.Log.ILogger)">
            <summary>
            give a way to explicitly set/replace the logger
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetLogger">
            <summary>
            ensure we have a logger by putting one from workspace service if one is not there already.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String)">
            <summary>
            log a specific event with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String})">
            <summary>
            log a specific event with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``1(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``2(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``3(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``4(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage)">
            <summary>
            log a specific event with a context message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetNextUniqueBlockId">
            <summary>
            return next unique pair id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Threading.CancellationToken)">
            <summary>
            simplest way to log a start and end pair
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Threading.CancellationToken)">
            <summary>
            simplest way to log a start and end pair with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String},System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``1(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``2(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``3(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``4(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger.RoslynLogBlock">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.LogMessage">
            <summary>
            log message that can generate string lazily
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.LogMessage.FreeCore">
            <summary>
            Logger will call this to return LogMessage to its pool
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndClear">
            <summary>
            Realizes the array and clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates">
            <summary>
            Provides pooled delegate instances to help avoid closure allocations for delegates that require a state argument
            with APIs that do not provide appropriate overloads with state arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``1(System.Action{``0},``0,System.Action@)">
             <summary>
             Gets an <see cref="T:System.Action"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(() => this.DoSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction(arg => arg.self.DoSomething(arg.x), (self: this, x), out Action action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``2(System.Action{``0,``1},``1,System.Action{``0}@)">
             <summary>
             Gets an <see cref="T:System.Action`1"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(a => this.DoSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, arg) => arg.self.DoSomething(a, arg.x), (self: this, x), out Action&lt;int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``3(System.Action{``0,``1,``2},``2,System.Action{``0,``1}@)">
             <summary>
             Gets an <see cref="T:System.Action`2"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b) => this.DoSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, arg) => arg.self.DoSomething(a, b, arg.x), (self: this, x), out Action&lt;int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``4(System.Action{``0,``1,``2,``3},``3,System.Action{``0,``1,``2}@)">
             <summary>
             Gets an <see cref="T:System.Action`3"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b, c) => this.DoSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, c, arg) => arg.self.DoSomething(a, b, c, arg.x), (self: this, x), out Action&lt;int, int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``2(System.Func{``0,``1},``0,System.Func{``1}@)">
             <summary>
             Gets a <see cref="T:System.Func`1"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(() => this.IsSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction(arg => arg.self.IsSomething(arg.x), (self: this, x), out Func&lt;bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``3(System.Func{``0,``1,``2},``1,System.Func{``0,``2}@)">
             <summary>
             Gets a <see cref="T:System.Func`2"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(a => this.IsSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, arg) => arg.self.IsSomething(a, arg.x), (self: this, x), out Func&lt;int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``4(System.Func{``0,``1,``2,``3},``2,System.Func{``0,``1,``3}@)">
             <summary>
             Gets a <see cref="T:System.Func`3"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b) => this.IsSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, arg) => arg.self.IsSomething(a, b, arg.x), (self: this, x), out Func&lt;int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``5(System.Func{``0,``1,``2,``3,``4},``3,System.Func{``0,``1,``2,``4}@)">
             <summary>
             Gets a <see cref="T:System.Func`4"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b, c) => this.IsSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, c, arg) => arg.self.IsSomething(a, b, c, arg.x), (self: this, x), out Func&lt;int, int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser">
             <summary>
             A releaser for a pooled delegate.
             </summary>
             <remarks>
             <para>This type is intended for use as the resource of a <c>using</c> statement. When used in this manner,
             <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> should not be called explicitly.</para>
            
             <para>If used without a <c>using</c> statement, calling <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is optional. If the call is
             omitted, the object will not be returned to the pool. The behavior of this type if <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is
             called multiple times is undefined.</para>
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.CreatePool(System.Int32)">
            <summary>
            If someone need to create a private pool
            </summary>
            <param name="size">The size of the pool.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.VerifySource(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Verify nodes match source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.FindFirstDifference(System.String,System.String)">
            <summary>
            Return the index of the first difference between
            the two strings, or -1 if the strings are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.IsHiddenPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if the provided position is in a hidden region inaccessible to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImmutableArrayExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">If items is null (default)</exception>
            <remarks>If the sequence is null, this will throw <see cref="T:System.ArgumentNullException"/></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return an empty array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])">
            <summary>
            Converts an array to an immutable array. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])">
            <summary>
            Converts a array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])">
            <summary>
            Converts an array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns>If the array is null, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1})">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
             Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Maps a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ZipAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``1},System.Func{``0,``1,``2})">
            <summary>
            Zips two immutable arrays together through a mapping function, producing another immutable array.
            </summary>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Casts the immutable array of a Type to an immutable array of its base type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether this instance and another immutable array are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <param name="comparer">The comparer to determine if the two arrays are equal.</param>
            <returns>True if the two arrays are equal</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an empty array if the input array is null (default)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an array of distinct elements, preserving the order in the original array.
            If the array has no duplicates, the original array is returned. The original array must not be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Clone">
            <summary>
            Make a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Invert">
            <summary>
            Invert all the bits in the vector.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BitVector.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.IntersectWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.UnionWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <returns>
            True if any bits were set as a result of the union.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsClrInteger(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsBlittable(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is a primitive of a fixed size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsPrimitiveRecursiveStruct(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. System.Int32 contains a field of type System.Int32).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsIntegralType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.VBForToShiftBits(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            For signed integer types return number of bits for their representation minus 1. 
            I.e. 7 for Int8, 31 for Int32, etc.
            Used for checking loop end condition for VB for loop.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``2(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1})">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2">
            <summary>
            A MultiDictionary that allows only adding, and preserves the order of values added to the 
            dictionary. Thread-safe for reading, but not for adding.
            </summary>
            <remarks>
            Always uses the default comparer.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Item(`0)">
            <summary>
            Get all values associated with K, in the order they were added.
            Returns empty read-only array if no values were present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Keys">
            <summary>
            Get a collection of all the keys.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.ValueSet._value">
            <summary>
            Each value is either a single V or an <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/>.
            Never null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_utf8Encoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.CreateFallbackEncoding">
            <summary>
            Encoding to use when UTF-8 fails. We try to find the following, in order, if available:
                1. The default ANSI codepage
                2. CodePage 1252.
                3. Latin1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF8 and, if that fails, it will
               try CodePage 1252. If CodePage 1252 is not available on the system, then it will try Latin1.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be Encoding.Default.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="canBeEmbedded">Indicates if the file can be embedded in the PDB.</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <param name="canBeEmbedded">Indicates if the text can be embedded in the PDB.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <exception cref="T:System.IO.IOException">Error reading from stream.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromStream(System.IO.Stream,System.ArraySegment{System.Byte}@)">
            <summary>
            Some streams are easily represented as bytes.
            </summary>
            <param name="data">The stream</param>
            <param name="bytes">The bytes, if available.</param>
            <returns>
            True if the stream's bytes could easily be read, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromFileStream(System.IO.FileStream,System.ArraySegment{System.Byte}@)">
            <summary>
            Read the contents of a FileStream into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="bytes">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RelativePathResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.RelativePathResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.DumpStackTrace(System.Exception,System.String)">
            <summary>
            Dumps the stack trace of the exception and the handler to the console. This is useful
            for debugging unit tests that hit a fatal exception
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.Assert(System.Boolean,System.String)">
            <summary>
            Checks for the given <paramref name="condition"/>; if the <paramref name="condition"/> is <c>true</c>, 
            immediately terminates the process without running any pending <c>finally</c> blocks or finalizers
            and causes a crash dump to be collected (if the system is configured to do so). 
            Otherwise, the process continues normally.
            </summary>
            <param name="condition">The conditional expression to evaluate.</param>
            <param name="message">An optional message to be recorded in the dump in case of failure. Can be <c>null</c>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler">
            <summary>
            Set by the host to a fail fast trigger, 
            if the host desires to crash the process on a fatal exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler">
            <summary>
            Set by the host to a fail fast trigger, 
            if the host desires to NOT crash the process on a non fatal exception.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error. 
            Unless the exception is <see cref="T:System.OperationCanceledException"/> 
            it calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/>. The exception is passed through (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Use in an exception filter to report a fatal error. 
            Calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/> unless the operation has been cancelled. 
            The exception is passed through (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatchUnlessCanceled(System.Exception)">
            <summary>
            Use in an exception filter to report a non-fatal error. 
            Unless the exception is <see cref="T:System.OperationCanceledException"/> 
            it calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler"/>. The exception isn't passed through (the method returns true).
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatchUnlessCanceled(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Use in an exception filter to report a non-fatal error. 
            Calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler"/> unless the operation has been cancelled. 
            The exception isn't passed through (the method returns true).
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagate(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error.
            Calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/> and passes the exception through (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatch(System.Exception)">
            <summary>
            Report a non-fatal error.
            Calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler"/> and doesn't pass the exception through (the method returns true).
            This is generally expected to be used within an exception filter as that allows us to
            capture data at the point the exception is thrown rather than when it is handled.
            However, it can also be used outside of an exception filter. If the exception has not
            already been thrown the method will throw and catch it itself to ensure we get a useful
            stack trace.
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackGuard.EnsureSufficientExecutionStack(System.Int32)">
            <summary>
                Ensures that the remaining stack space is large enough to execute
                the average function.
            </summary>
            <param name="recursionDepth">how many times the calling function has recursed</param>
            <exception cref="T:System.InsufficientExecutionStackException">
                The available stack space is insufficient to execute
                the average function.
            </exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImports.AddImportPlacement">
            <summary>
            Specifies the desired placement of added imports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImports.AddImportPlacement.InsideNamespace">
            <summary>
            Place imports inside the namespace definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImports.AddImportPlacement.OutsideNamespace">
            <summary>
            Place imports outside the namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArrayExtensions.AsRef``1(Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{``0}@)">
             <summary>
             Gets a mutable reference to a <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/> stored in a <c>using</c> variable.
             </summary>
             <remarks>
             <para>This supporting method allows <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/>, a non-copyable <see langword="struct"/>
             implementing <see cref="T:System.IDisposable"/>, to be used with <c>using</c> statements while still allowing them to
             be passed by reference in calls. The following two calls are equivalent:</para>
            
             <code>
             using var array = TemporaryArray&lt;T&gt;.Empty;
            
             // Using the 'Unsafe.AsRef' method
             Method(ref Unsafe.AsRef(in array));
            
             // Using this helper method
             Method(ref array.AsRef());
             </code>
            
             <para>⚠ Do not move or rename this method without updating the corresponding
             <see href="https://github.com/dotnet/roslyn-analyzers/blob/30180a51af8c4711e51d98df7345f14d083efb63/src/Roslyn.Diagnostics.Analyzers/Core/TemporaryArrayAsRefAnalyzer.cs">RS0049</see>
             analyzer.</para>
             </remarks>
             <typeparam name="T">The type of element stored in the temporary array.</typeparam>
             <param name="array">A read-only reference to a temporary array which is part of a <c>using</c> statement.</param>
             <returns>A mutable reference to the temporary array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1">
            <summary>
            Provides temporary storage for a collection of elements. This type is optimized for handling of small
            collections, particularly for cases where the collection will eventually be discarded or used to produce an
            <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <remarks>
            This type stores small collections on the stack, with the ability to transition to dynamic storage if/when
            larger number of elements are added.
            </remarks>
            <typeparam name="T">The type of elements stored in the collection.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.InlineCapacity">
            <summary>
            The number of elements the temporary can store inline. Storing more than this many elements requires the
            array transition to dynamic storage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0">
            <summary>
            The first inline element.
            </summary>
            <remarks>
            This field is only used when <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is <see langword="null"/>. In other words, this type
            stores elements inline <em>or</em> stores them in <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/>, but does not use both approaches
            at the same time.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item1">
            <summary>
            The second inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item2">
            <summary>
            The third inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item3">
            <summary>
            The fourth inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._count">
            <summary>
            The number of inline elements held in the array. This value is only used when <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is
            <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder">
            <summary>
            A builder used for dynamic storage of collections that may exceed the limit for inline elements.
            </summary>
            <remarks>
            This field is initialized to non-<see langword="null"/> the first time the <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/>
            needs to store more than four elements. From that point, <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is used instead of inline
            elements, even if items are removed to make the result smaller than four elements.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ToImmutableAndClear">
            <summary>
            Create an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with the elements currently held in the temporary array, and clear
            the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.MoveInlineToBuilder">
            <summary>
            Transitions the current <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/> from inline storage to dynamic storage storage. An
            <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/> instance is taken from the shared pool, and all elements currently in inline
            storage are added to it. After this point, dynamic storage will be used instead of inline storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ThrowIndexOutOfRangeException">
            <summary>
            Throws <see cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <remarks>
            This helper improves the ability of the JIT to inline callers.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1">
            <summary>
            An interval tree represents an ordered tree data structure to store intervals of the form 
            [start, end).  It allows you to efficiently find all intervals that intersect or overlap 
            a provided interval.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1.FillWithIntervalsThatMatch``1(System.Int32,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.IntervalTree{`0}.TestInterval{``0},Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{`0}@,``0@,System.Boolean)">
            <returns>The number of matching intervals found by the method.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1.FillWithIntervalsThatMatch``1(System.Int32,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.IntervalTree{`0}.TestInterval{``0},Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{`0}@,``0@,System.Boolean,System.Collections.Generic.Stack{System.ValueTuple{Microsoft.CodeAnalysis.Shared.Collections.IntervalTree{`0}.Node,System.Boolean}})">
            <returns>The number of matching intervals found by the method.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree`2.AddIntervalInPlace(`0)">
            <summary>
            Warning.  Mutates the tree in place.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CompilationExtensions.GetBestTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String)">
             <summary>
             Gets a type by its metadata name to use for code analysis within a <see cref="T:Microsoft.CodeAnalysis.Compilation"/>. This method
             attempts to find the "best" symbol to use for code analysis, which is the symbol matching the first of the
             following rules.
            
             <list type="number">
               <item><description>
                 If only one type with the given name is found within the compilation and its referenced assemblies, that
                 type is returned regardless of accessibility.
               </description></item>
               <item><description>
                 If the current <paramref name="compilation"/> defines the symbol, that symbol is returned.
               </description></item>
               <item><description>
                 If exactly one referenced assembly defines the symbol in a manner that makes it visible to the current
                 <paramref name="compilation"/>, that symbol is returned.
               </description></item>
               <item><description>
                 Otherwise, this method returns <see langword="null"/>.
               </description></item>
             </list>
             </summary>
             <param name="compilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> to consider for analysis.</param>
             <param name="fullyQualifiedMetadataName">The fully-qualified metadata type name to find.</param>
             <returns>The symbol to use for code analysis; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.GetEffectiveSeverity(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.CompilationOptions,System.Nullable{Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult})">
            <summary>
            Gets project-level effective severity of the given <paramref name="descriptor"/> accounting for severity configurations from both the following sources:
            1. Compilation options from ruleset file, if any, and command line options such as /nowarn, /warnaserror, etc.
            2. Analyzer config documents at the project root directory or in ancestor directories.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.TryGetSeverityFromBulkConfiguration(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult,Microsoft.CodeAnalysis.ReportDiagnostic@)">
            <summary>
            Tries to get configured severity for the given <paramref name="descriptor"/>
            from bulk configuration analyzer config options, i.e.
                'dotnet_analyzer_diagnostic.category-%RuleCategory%.severity = %severity%'
                    or
                'dotnet_analyzer_diagnostic.severity = %severity%'
            Docs: https://docs.microsoft.com/visualstudio/code-quality/use-roslyn-analyzers?view=vs-2019#set-rule-severity-of-multiple-analyzer-rules-at-once-in-an-editorconfig-file for details
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ListExtensions.RemoveOrTransformAll``2(System.Collections.Generic.List{``0},System.Func{``0,``1,``0},``1)">
            <summary>
            Update a list in place, where a function has the ability to either transform or remove each item.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <typeparam name="TArg">The type of state argument passed to the transformation callback.</typeparam>
            <param name="list">The list to update.</param>
            <param name="transform">A function which transforms each element. The function returns the transformed list
            element, or <see langword="null"/> to remove the current item from the list.</param>
            <param name="arg">The state argument to pass to the transformation callback.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about the parent of a token.
            </summary>
            <param name="semanticModel">The SemanticModel object to get semantic information
            from.</param>
            <param name="token">The token to get semantic information from. This must be part of the
            syntax tree associated with the binding.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SimpleIntervalTreeExtensions.HasIntervalThatIntersectsWith(Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree{Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector},Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            check whether the given span is intersects with the tree
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.TryOverlapsHiddenPosition(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Func{System.Int32,System.Threading.CancellationToken,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Same as OverlapsHiddenPosition but doesn't throw on cancellation.  Instead, returns false
            in that case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.IsChildNode``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if is a given token is a child token of a certain type of parent node.
            </summary>
            <typeparam name="TParent">The type of the parent node.</typeparam>
            <param name="node">The node that we are testing.</param>
            <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.IsFoundUnder``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if this node is found underneath the specified child in the given parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the tokens
            
            tokens should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the nodes
            
            nodes should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ReplaceNodesAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of nodes from the existing tree with the specified old nodes replaced with a newly computed nodes.
            </summary>
            <param name="root">The root of the tree that contains all the specified nodes.</param>
            <param name="nodes">The nodes from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement node for
            the argument nodes. The first argument is one of the original specified nodes. The second argument is
            the same node possibly rewritten with replaced descendants.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ReplaceTokensAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxToken}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of tokens from the existing tree with the specified old tokens replaced with a newly computed tokens.
            </summary>
            <param name="root">The root of the tree that contains all the specified tokens.</param>
            <param name="tokens">The tokens from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement token for
            the argument tokens. The first argument is one of the originally specified tokens. The second argument is
            the same token possibly rewritten with replaced trivia.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.s_findSkippedTokenForward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindSkippedTokenForward(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.s_findSkippedTokenBackward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindSkippedTokenBackward(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.WithoutLeadingTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token with the leading trivia removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.WithoutTrailingTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token with the trailing trivia removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ValueAncestorsAndSelf(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.GetTouchingWordAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns the identifier, keyword, contextual keyword or preprocessor keyword touching this
            position, or a token of Kind = None if the caret is not touching either.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespacePosition(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line, or null if 
            the line is empty or contains only whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespaceOffset(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line as an offset
            from the start of the line, or null if the line is empty or contains only
            whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.IsEmptyOrWhitespace(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Determines whether the specified line is empty or contains whitespace only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.ToNormalizedSpans(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            merge provided spans to each distinct group of spans in ascending order
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.IsAround(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns true if the span encompasses the specified node or token and is contained within its trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.IsAround(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns true if the span encompasses a span between the specified nodes or tokens
            and is contained within trivia around them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions.HasEventHandlerSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true for void returning methods with two parameters, where
            the first parameter is of <see cref="T:System.Object"/> type and the second
            parameter inherits from or equals <see cref="T:System.EventArgs"/> type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions.GetOverridableMembers(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the set of members in the inheritance chain of <paramref name="containingType"/> that
            are overridable.  The members will be returned in furthest-base type to closest-base
            type order.  i.e. the overridable members of <see cref="T:System.Object"/> will be at the start
            of the list, and the members of the direct parent type of <paramref name="containingType"/> 
            will be at the end of the list.
            
            If a member has already been overridden (in <paramref name="containingType"/> or any base type) 
            it will not be included in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions.GetAllTypes(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Lazily returns all nested types contained (recursively) within this namespace or type.
            In case of a type, it is included itself as the first result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.RequiresUnsafeModifier(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns <see langword="true"/> if the signature of this symbol requires the <see
            langword="unsafe"/> modifier.  For example a method that takes <c>List&lt;int*[]&gt;</c>
            is unsafe, as is <c>int* Goo { get; }</c>.  This will return <see langword="false"/> for
            symbols that cannot have the <see langword="unsafe"/> modifier on them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsInaccessibleLocal(Microsoft.CodeAnalysis.ISymbol,System.Int32)">
            <returns>
            Returns true if symbol is a local variable and its declaring syntax node is 
            after the current position, false otherwise (including for non-local symbols)
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAwaitableNonDynamic(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32)">
            <summary>
            If the <paramref name="symbol"/> is a method symbol, returns <see langword="true"/> if the method's return type is "awaitable", but not if it's <see langword="dynamic"/>.
            If the <paramref name="symbol"/> is a type symbol, returns <see langword="true"/> if that type is "awaitable".
            An "awaitable" is any type that exposes a GetAwaiter method which returns a valid "awaiter". This GetAwaiter method may be an instance method or an extension method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolWithSpecialDiscardName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true for symbols whose name starts with an underscore and
            are optionally followed by an integer, such as '_', '_1', '_2', etc.
            These are treated as special discard symbol names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsObsolete(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns <see langword="true"/>, if the symbol is marked with the <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
            <param name="symbol"></param>
            <returns><see langword="true"/> if the symbol is marked with the <see cref="T:System.ObsoleteAttribute"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.RequiresUnsafeModifierVisitor">
            <summary>
            Visits types or members that have signatures (i.e. methods, fields, etc.) and determines
            if any of them reference a pointer type and should thus have the <see
            langword="unsafe"/> modifier on them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within name type 'within', with an optional
            qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessible(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within', with an qualifier of
            type "throughTypeOpt". Sets "failedThroughTypeCheck" to true if it failed the "through
            type" check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a INamedTypeSymbol
            or an IAssemblySymbol.  If 'symbol' is accessed off of an expression then
            'throughTypeOpt' is the type of that expression. This is needed to properly do protected
            access checks. Sets "failedThroughTypeCheck" to true if this protected check failed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.NameFormat">
            <summary>
            Standard format for displaying to the user.
            </summary>
            <remarks>
            No return type.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.SignatureFormat">
            <summary>
            Contains enough information to determine whether two symbols have the same signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that is
            empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified span.
            </summary>
            <param name="span">TextSpan contained by the span set.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified list of spans.
            </summary>
            <param name="spans">The spans to be added.</param>
            <remarks>
            <para>The list of spans will be sorted and normalized (overlapping and adjoining spans will be combined).</para>
            <para>This constructor runs in O(N log N) time, where N = spans.Count.</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="spans"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Union(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the union of two span sets.
            </summary>
            <param name="left">
            The first span set.
            </param>
            <param name="right">
            The second span set.
            </param>
            <returns>
            The new span set that corresponds to the union of <paramref name="left"/> and <paramref name="right"/>.
            </returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException">Either <paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Overlap(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the overlap of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the overlap of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Intersection(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the intersection of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the intersection of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Difference(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the difference between two sets. The difference is defined as everything in the first span set that is not in the second span set.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the difference between <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>
            Empty spans in the second set do not affect the first set at all. This method returns empty spans in the first set that are not contained by any set in
            the second set.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Equality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are the same. 
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Inequality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are not the same.
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are not equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set overlaps with another span set.
            </summary>
            <param name="set">The span set to test.</param>
            <returns><c>true</c> if the span sets overlap, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set overlaps with another span.
            </summary>
            <param name="span">The span to test.</param>
            <returns><c>true</c> if this span set overlaps with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set intersects with another span set.
            </summary>
            <param name="set">Set to test.</param>
            <returns><c>true</c> if the span sets intersect, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set intersects with another span.
            </summary>
            <returns><c>true</c> if this span set intersects with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.GetHashCode">
            <summary>
            Gets a unique hash code for the span set.
            </summary>
            <returns>A 32-bit hash code associated with the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Equals(System.Object)">
            <summary>
            Determines whether this span set is the same as another object.
            </summary>
            <param name="obj">The object to test.</param>
            <returns><c>true</c> if the two objects are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.ToString">
            <summary>
            Provides a string representation of the set.
            </summary>
            <returns>The string representation of the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OrderedSpanList)">
            <summary>
            Private constructor for use when the span list is already normalized.
            </summary>
            <param name="normalizedSpans">An already normalized span list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Creates a task that will complete after a time delay, but can be expedited if an operation is waiting for
            the task to complete.
            </summary>
            <param name="delay">The time to wait before completing the returned task, or <c>TimeSpan.FromMilliseconds(-1)</c> to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe while waiting for the task to complete.</param>
            <returns><see langword="true"/> if the delay compeleted normally; otherwise, <see langword="false"/> if the delay completed due to a request to expedite the delay.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="delay"/> represents a negative time interval other than <c>TimeSpan.FromMilliseconds(-1)</c>.</para>
            <para>-or-</para>
            <para>The <paramref name="delay"/> argument's <see cref="P:System.TimeSpan.TotalMilliseconds"/> property is greater than <see cref="F:System.Int32.MaxValue"/>.</para>
            </exception>
            <exception cref="T:System.OperationCanceledException">The delay has been canceled.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7">
            <summary>
            Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
            Given an expression node from a syntax tree and a new expression from a different syntax tree,
            it replaces the expression with the new expression to create a speculated syntax tree.
            It uses the original tree's semantic model to create a speculative semantic model and verifies that
            the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.#ctor(`0,`0,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
            <summary>
            Creates a semantic analyzer for speculative syntax replacement.
            </summary>
            <param name="expression">Original expression to be replaced.</param>
            <param name="newExpression">New expression to replace the original expression.</param>
            <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="skipVerificationForReplacedNode">
            True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
            This could be the case when custom verifications are required to be done by the caller or
            semantics of the replaced expression are different from the original expression.
            </param>
            <param name="failOnOverloadResolutionFailuresInOriginalCode">
            True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression">
            <summary>
            Original expression to be replaced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfOriginalExpression">
            <summary>
            First ancestor of <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> which is either a statement, attribute, constructor initializer,
            field initializer, default parameter initializer or type syntax node.
            It serves as the root node for all semantic analysis for this syntax replacement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalSemanticModel">
            <summary>
            Semantic model for the syntax tree corresponding to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacedExpression">
            <summary>
            Node which replaces the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/>.
            Note that this node is a cloned version of <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7._newExpressionForReplace"/> node, which has been re-parented
            under the node to be speculated, i.e. <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfReplacedExpression"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfReplacedExpression">
            <summary>
            Node created by replacing <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> under <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfOriginalExpression"/> node.
            This node is used as the argument to the GetSpeculativeSemanticModel API and serves as the root node for all
            semantic analysis of the speculated tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SpeculativeSemanticModel">
            <summary>
            Speculative semantic model used for analyzing the semantics of the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacementChangesSemantics">
            <summary>
            Determines whether performing the given syntax replacement will change the semantics of any parenting expressions
            by performing a bottom up walk from the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfOriginalExpression"/>
            in the original tree and simultaneously walking bottom up from <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacedExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfReplacedExpression"/>
            in the speculated syntax tree and performing appropriate semantic comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SymbolsForOriginalAndReplacedNodesAreCompatible">
            <summary>
            Checks whether the semantic symbols for the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> and <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacedExpression"/> are non-null and compatible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacementBreaksSystemObjectMethodResolution(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if removing the cast could cause the semantics of System.Object method call to change.
            E.g. Dim b = CStr(1).GetType() is necessary, but the GetType method symbol info resolves to the same with or without the cast.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.IsSymbolSystemObjectInstanceMethod(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is a non-overridable, non static method on System.Object (e.g. GetType)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.AppendPartialLeadingTriviaText(Microsoft.CodeAnalysis.SyntaxToken,System.Text.StringBuilder,System.Int32)">
            <summary>
            If the token1 is expected to be part of the leading trivia of the token2 then the trivia
            before the token1FullSpanEnd, which the fullspan end of the token1 should be ignored
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            this will create a span that includes its trailing trivia of its previous token and leading trivia of its next token
            for example, for code such as "class A { int ...", if given tokens are "A" and "{", this will return span [] of "class[ A { ]int ..."
            which included trailing trivia of "class" which is previous token of "A", and leading trivia of "int" which is next token of "{"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities.Convert(System.Int64,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Helper as VB's CType doesn't work without arithmetic overflow.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1">
            <summary>
            Helper class to allow one to do simple regular expressions over a sequence of objects (as
            opposed to a sequence of characters).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Repeat``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m*)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.OneOrMore``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m+)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Choice``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1|m_2|...|m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Sequence``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1 ... m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Single``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Matcher that matches an element if the provide predicate returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker.GetWordParts(System.String)">
            <summary>
            Breaks an identifier string into constituent parts.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer">
            <summary>
            Provides a way to test two symbols for equivalence.  While there are ways to ask for
            different sorts of equivalence, the following must hold for two symbols to be considered
            equivalent.
            <list type="number">
            <item>The kinds of the two symbols must match.</item>
            <item>The names of the two symbols must match.</item>
            <item>The arity of the two symbols must match.</item>
            <item>If the symbols are methods or parameterized properties, then the signatures of the two
            symbols must match.</item>
            <item>Both symbols must be definitions or must be instantiations.  If they are instantiations,
            then they must be instantiated in the same manner.</item>
            <item>The containing symbols of the two symbols must be equivalent.</item>
            <item>Nullability of symbols is not involved in the comparison.</item>
            </list>
            Note: equivalence does not concern itself with whole symbols.  Two types are considered
            equivalent if the above hold, even if one type has different members than the other.  Note:
            type parameters, and signature parameters are not considered 'children' when comparing
            symbols.
            
            Options are provided to tweak the above slightly.  For example, by default, symbols are
            equivalent only if they come from the same assembly or different assemblies of the same simple name.
            However, one can ask if two symbols are equivalent even if their assemblies differ.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence and populates <paramref name="equivalentTypesWithDifferingAssemblies"/>
            with equivalent non-nested named type key-value pairs that are contained in different assemblies.
            These equivalent named type key-value pairs represent possibly equivalent forwarded types, but this API doesn't perform any type forwarding equivalence checks. 
            </summary>
            <remarks>This API is only supported for <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.IgnoreAssembliesInstance"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.EquivalenceVisitor.HandleNamedTypesWorker(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Worker for comparing two named types for equivalence. Note: The two
            types must have the same TypeKind.
            </summary>
            <param name="x">The first type to compare</param>
            <param name="y">The second type to compare</param>
            <param name="equivalentTypesWithDifferingAssemblies">
            Map of equivalent non-nested types to be populated, such that each key-value pair of named types are equivalent but reside in different assemblies.
            This map is populated only if we are ignoring assemblies for symbol equivalence comparison, i.e. <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer._assemblyComparerOpt"/> is true.
            </param>
            <returns>True if the two types are equivalent.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic">
            <summary>
            Represents an error in a embedded language snippet.  The error contains the message to show 
            a user as well as the span of the error.  This span is in actual user character coordinates.
            For example, if the user has the string "...\\p{0}..." then the span of the error would be 
            for the range of characters for '\\p{0}' (even though the regex engine would only see the \\ 
            translated as a virtual char to the single \ character.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2">
            <summary>
            Root of the embedded language syntax hierarchy.  EmbeddedSyntaxNodes are very similar to 
            Roslyn Red-Nodes in concept, though there are differences for ease of implementation.
            
            Similarities:
            1. Fully representative of the original source.  All source VirtualChars are contained
               in the Regex nodes.
            2. Specific types for Nodes, Tokens and Trivia.
            3. Uniform ways of deconstructing Nodes (i.e. ChildCount + ChildAt).
            
            Differences:
            Note: these differences are not required, and can be changed if felt to be valuable.
            1. No parent pointers.  These have not been needed yet.
            2. No Update methods.  These have not been needed yet.
            3. No direct ways to get Positions/Spans of node/token/trivia.  Instead, that information can
               be acquired from the VirtualChars contained within those constructs.  This does mean that
               an empty node (for example, an empty RegexSequenceNode) effect has no way to simply ascertain
               its location.  So far that hasn't been a problem.
            4. No null nodes.  Haven't been needed so far, and it keeps things extremely simple.  For 
               example where Roslyn might have chosen an optional null child, the Regex hierarchy just
               has multiple nodes.  For example there are distinct nodes to represent the very similar
               {a}   {a,}    {a,b}    constructs.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer capture,
            then this property would return the actual integer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1">
            <summary>
            Trivia on an <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1.Diagnostics">
            <summary>
            A place for diagnostics to be stored during parsing.  Not intended to be accessed 
            directly.  These will be collected and aggregated into <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTree`3.Diagnostics"/>
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.IsLegalBraceEscape(System.String,System.Int32,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Returns <see langword="true"/> if the next two characters at <c>tokenText[index]</c> are <c>{{</c> or
            <c>}}</c>.  If so, <paramref name="span"/> will contain the span of those two characters (based on <paramref
            name="tokenText"/> starting at <paramref name="offset"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.TryConvertSimpleDoubleQuoteString(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)">
            <summary>
            Helper to convert simple string literals that escape quotes by doubling them.  This is 
            how normal VB literals and c# verbatim string literals work.
            </summary>
            <param name="startDelimiter">The start characters string.  " in VB and @" in C#</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService">
             <summary>
             Helper service that takes the raw text of a string token and produces the individual
             characters that raw string token represents (i.e. with escapes collapsed).  The difference
             between this and the result from token.ValueText is that for each collapsed character
             returned the original span of text in the original token can be found.  i.e. if you had the
             following in C#:
            
             "G\u006fo"
            
             Then you'd get back:
            
             'G' -> [0, 1) 'o' -> [1, 7) 'o' -> [7, 1)
            
             This allows for embedded language processing that can refer back to the users' original code
             instead of the escaped value we're processing.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService.TryConvertToVirtualChars(Microsoft.CodeAnalysis.SyntaxToken)">
             <summary>
             Takes in a string token and return the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s corresponding to each
             char of the tokens <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText"/>.  In other words, for each char
             in ValueText there will be a VirtualChar in the resultant array.  Each VirtualChar will
             specify what char the language considers them to represent, as well as the span of text
             in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that the language created that char from. 
            
             For most chars this will be a single character span.  i.e. 'c' -> 'c'.  However, for
             escapes this may be a multi character span.  i.e. 'c' -> '\u0063'
            
             If the token is not a string literal token, or the string literal has any diagnostics on
             it, then <see langword="default"/> will be returned.   Additionally, because a
             VirtualChar can only represent a single char, while some escape sequences represent
             multiple chars, <see langword="default"/> will also be returned in those cases. All
             these cases could be relaxed in the future.  But they greatly simplify the
             implementation.
            
             If this function succeeds, certain invariants will hold.  First, each character in the
             sequence of characters in <paramref name="token"/>.ValueText will become a single
             VirtualChar in the result array with a matching <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/> property.
             Similarly, each VirtualChar's <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Span"/> will abut each other, and
             the union of all of them will cover the span of the token's <see
             cref="P:Microsoft.CodeAnalysis.SyntaxToken.Text"/>
             *not* including the start and quotes.
            
             In essence the VirtualChar array acts as the information explaining how the <see
             cref="P:Microsoft.CodeAnalysis.SyntaxToken.Text"/> of the token between the quotes maps to each character in the
             token's <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText"/>.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService.TryGetEscapeCharacter(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar,System.Char@)">
            <summary>
            Produces the appropriate escape version of <paramref name="ch"/> to be placed in a
            normal string literal.  For example if <paramref name="ch"/> is the <c>tab</c>
            character, then this would produce <c>t</c> as <c>\t</c> is what would go into a string
            literal.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> provides a uniform view of a language's string token characters regardless if they
            were written raw in source, or are the production of a language escape sequence.  For example, in C#, in a
            normal <c>""</c> string a <c>Tab</c> character can be written either as the raw tab character (value <c>9</c> in
            ASCII),  or as <c>\t</c>.  The format is a single character in the source, while the latter is two characters
            (<c>\</c> and <c>t</c>).  <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> will represent both, providing the raw <see cref="T:System.Char"/>
            value of <c>9</c> as well as what <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> they occupied.
            </summary>
            <remarks>
            A core consumer of this system is the Regex parser.  That parser wants to work over an array of characters,
            however this array of characters is not the same as the array of characters a user types into a string in C# or
            VB. For example In C# someone may write: @"\z".  This should appear to the user the same as if they wrote "\\z"
            and the same as "\\\u007a".  However, as these all have wildly different presentations for the user, there needs
            to be a way to map back the characters it sees ( '\' and 'z' ) back to the  ranges of characters the user wrote.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune">
            <summary>
            The value of this <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> as a <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/> if such a represention is possible.
            <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>s can represent Unicode codepoints that can appear in a <see cref="T:System.String"/> except for
            unpaired surrogates.  If an unpaired high or low surrogate character is present, this value will be <see
            cref="P:System.Text.Rune.ReplacementChar"/>.  The value of this character can be retrieved from
            <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.SurrogateChar"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.SurrogateChar">
            <summary>
            The unpaired high or low surrogate character that was encountered that could not be represented in <see
            cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>.  If <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/> is not <see cref="P:System.Text.Rune.ReplacementChar"/>, this will be <c>0</c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Span">
            <summary>
            The span of characters in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that represent this <see
            cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Create(System.Text.Rune,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> from the provided <paramref name="rune"/>.  This operation cannot
            fail.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Create(System.Char,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> from an unpaired high or low surrogate character.  This will throw
            if <paramref name="surrogateChar"/> is not actually a surrogate character. The resultant <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>
            value will be <see cref="P:System.Text.Rune.ReplacementChar"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Value">
            <summary>
            Retrieves the scaler value of this character as an <see cref="T:System.Int32"/>.  If this is an unpaired surrogate
            character, this will be the value of that surrogate.  Otherwise, this will be the value of our <see
            cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence">
             <summary>
             Represents the individual characters that raw string token represents (i.e. with escapes collapsed).  
             The difference between this and the result from token.ValueText is that for each collapsed character
             returned the original span of text in the original token can be found.  i.e. if you had the
             following in C#:
            
             "G\u006fo"
            
             Then you'd get back:
            
             'G' -> [0, 1) 'o' -> [1, 7) 'o' -> [7, 1)
            
             This allows for embedded language processing that can refer back to the user's original code
             instead of the escaped value we're processing.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk">
            <summary>
            Abstraction over a contiguous chunk of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s.  This
            is used so we can expose <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s over an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            or over a <see cref="T:System.String"/>.  The latter is especially useful for reducing
            memory usage in common cases of string tokens without escapes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.ImmutableArrayChunk">
            <summary>
            Thin wrapper over an actual <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            This will be the common construct we generate when getting the
            <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> for a string token that has escapes in it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.StringChunk">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> on top of a normal
            string.  This is the common case of the type of the sequence we would
            create for a normal string token without any escapes in it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.StringChunk._underlyingData">
            <summary>
            The underlying string that we're returning virtual chars from.  Note:
            this will commonly include things like quote characters.  Clients who
            do not want that should then ask for an appropriate <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.GetSubSequence(Microsoft.CodeAnalysis.Text.TextSpan)"/>
            back that does not include those characters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._leafCharacters">
            <summary>
            The actual characters that this <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/> is a portion of.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._span">
            <summary>
            The portion of <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._leafCharacters"/> that is being exposed.  This span 
            is `[inclusive, exclusive)`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.FromBounds(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence)">
            <summary>
            Combines two <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>s, producing a final
            sequence that points at the same underlying data, but spans from the 
            start of <paramref name="chars1"/> to the end of <paramref name="chars2"/>.
            </summary>  
        </member>
        <member name="M:Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetPrecedenceKind(System.Int32)">
            <summary>
            Returns the precedence of the given expression, mapped down to one of the 
            <see cref="T:Microsoft.CodeAnalysis.Precedence.PrecedenceKind"/> values.  The mapping is language specific.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetOperatorPrecedence(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the precedence of this expression in a scale specific to a particular
            language.  These values cannot be compared across languages, but relates the 
            precedence of expressions in the same language.  A smaller value means lower
            precedence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.CustomDataFlowAnalysis`1.Run(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer{`0},System.Threading.CancellationToken)">
            <summary>
            Runs dataflow analysis for the given <paramref name="analyzer"/> on the given <paramref name="controlFlowGraph"/>.
            </summary>
            <param name="controlFlowGraph">Control flow graph on which to execute analysis.</param>
            <param name="analyzer">Dataflow analyzer.</param>
            <returns>Block analysis data at the end of the exit block.</returns>
            <remarks>
            Algorithm for this CFG walker has been forked from <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder"/>'s internal
            implementation for basic block reachability computation: "MarkReachableBlocks",
            we should keep them in sync as much as possible.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1">
            <summary>
            Analyzer to execute custom dataflow analysis on a control flow graph.
            </summary>
            <typeparam name="TBlockAnalysisData">Custom data tracked for each basic block with values at start of the block.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.GetCurrentAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock)">
            <summary>
            Gets current analysis data for the given basic block, or an empty analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.GetEmptyAnalysisData">
            <summary>
            Gets empty analysis data for first analysis pass on a basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.SetCurrentAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Updates the current analysis data for the given basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeBlock(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,System.Threading.CancellationToken)">
            <summary>
            Analyze the given basic block and return the block analysis data at the end of the block for its successors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeNonConditionalBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Analyze the non-conditional fallthrough successor branch for the given basic block
            and return the block analysis data for the branch destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeConditionalBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Analyze the given conditional branch for the given basic block and return the
            block analysis data for the branch destinations for the fallthrough and
            conditional successor branches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.Merge(`0,`0,System.Threading.CancellationToken)">
            <summary>
            Merge the given block analysis data instances to produce the resultant merge data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.IsEqual(`0,`0)">
            <summary>
            Returns true if both the given block analysis data instances should be considered equivalent by analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeUnreachableBlocks">
            <summary>
            Flag indicating if the dataflow analysis should run on unreachable blocks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind">
            <summary>
            Indicates the kind of flow capture in an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.RValueCapture">
            <summary>
            Indicates an R-Value flow capture, i.e. capture of a symbol's value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.LValueCapture">
            <summary>
            Indicates an L-Value flow capture, i.e. captures of a symbol's location/address.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.LValueAndRValueCapture">
            <summary>
            Indicates both an R-Value and an L-Value flow capture, i.e. captures of a symbol's value and location/address.
            These are generated for left of a compound assignment operation, such that there is conditional code on the right side of the compound assignment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.LValueFlowCapturesProvider">
            <summary>
            Helper class to detect <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>s that are l-value captures.
            L-value captures are essentially captures of a symbol's location/address.
            Corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation"/>s which share the same
            <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId"/> as this flow capture, dereferences and writes to this location
            subsequently in the flow graph.
            For example, consider the below code:
                a[i] = x ?? a[j];
            The control flow graph contains an initial flow capture of "a[i]" to capture the l-value
            of this array element:
                FC0 (a[i])
            Then it evaluates the right hand side, which can have different
            values on different control flow paths, and the resultant value is then written
            to the captured location:
                FCR0 = result
            </summary>
            <remarks>
            NOTE: This type is a workaround for https://github.com/dotnet/roslyn/issues/31007
            and it can be deleted once that feature is implemented.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis">
            <summary>
            Analysis to compute all the symbol writes for local and parameter
            symbols in an executable code block, along with the information of whether or not the definition
            may be read on some control flow path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData">
            <summary>
            Core analysis data to drive the operation <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Walker"/>
            for operation tree based analysis OR control flow graph based analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData._allocatedBasicBlockAnalysisDatas">
            <summary>
            Pooled <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData"/> allocated during analysis with the
            current <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData"/> instance, which will be freed during <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.Dispose"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData._referenceTakenSymbolsBuilder">
            <summary>
            Set of locals/parameters which are passed by reference to other method calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.SymbolsWriteBuilder">
            <summary>
            Map from each (symbol, write) to a boolean indicating if the value assigned
            at the write is read on some control flow path.
            For example, consider the following code:
            <code>
                int x = 0;
                x = 1;
                Console.WriteLine(x);
            </code>
            This map will have two entries for 'x':
                1. Key = (symbol: x, write: 'int x = 0')
                   Value = 'false', because value assigned to 'x' here **is never** read. 
                2. Key = (symbol: x, write: 'x = 1')
                   Value = 'true', because value assigned to 'x' here **may be** read on
                   some control flow path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.SymbolsReadBuilder">
            <summary>
            Set of locals/parameters that are read at least once.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.LambdaOrLocalFunctionsBeingAnalyzed">
            <summary>
            Set of lambda/local functions whose invocations are currently being analyzed to prevent
            infinite recursion for analyzing code with recursive lambda/local function calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.CurrentBlockAnalysisData">
            <summary>
            Current block analysis data used for analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.AdditionalConditionalBranchAnalysisData">
            <summary>
            Block analysis data used for an additional conditional branch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.ToResult">
            <summary>
            Creates an immutable <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult"/> for the current analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.ResetState">
            <summary>
            Resets all the currently tracked symbol writes to be conservatively marked as read.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData">
            <summary>
            Analysis data for a particular <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/> for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>
            based dataflow analysis OR for the entire executable code block for high level operation
            tree based analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData._reachingWrites">
            <summary>
            Map from each symbol to possible set of reachable write operations that are live at current program point.
            A write is live if there is no intermediate write operation that overwrites it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.GetCurrentWrites(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the currently reachable writes for the given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.OnWriteReferenceFound(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IOperation,System.Boolean)">
            <summary>
            Marks the given symbol write as a new unread write operation,
            potentially clearing out the prior write operations if <paramref name="maybeWritten"/> is <code>false</code>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Run(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Runs dataflow analysis on the given control flow graph to compute symbol usage results
            for symbol read/writes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Run(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Runs a fast, non-precise operation tree based analysis to compute symbol usage results
            for symbol read/writes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer">
            <summary>
            Dataflow analysis to compute symbol usage information (i.e. reads/writes) for locals/parameters
            in a given control flow graph, along with the information of whether or not the writes
            may be read on some control flow path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._analysisDataByBasicBlockMap">
            <summary>
            Map from basic block to current <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData"/> for dataflow analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._analyzeLocalFunctionOrLambdaInvocation">
            <summary>
            Callback to analyze lambda/local function invocations and return new block analysis data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._lValueFlowCapturesMap">
            <summary>
            Map from flow capture ID to set of captured symbol addresses along all possible control flow paths.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._reachingDelegateCreationTargets">
            <summary>
            Map from operations to potential delegate creation targets that could be invoked via delegate invocation
            on the operation.
            Used to analyze delegate creations/invocations of lambdas and local/functions defined in a method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._localFunctionTargetsToAccessingCfgMap">
            <summary>
            Map from local functions to the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.ControlFlowGraph"/> where the local function was accessed
            to create an invocable delegate. This control flow graph is required to lazily get or create the
            control flow graph for this local function at delegate invocation callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._lambdaTargetsToAccessingCfgMap">
            <summary>
            Map from lambdas to the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.ControlFlowGraph"/> where the lambda was defined
            to create an invocable delegate. This control flow graph is required to lazily get or create the
            control flow graph for this lambda at delegate invocation callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._symbolWritesInsideBlockRangeMap">
            <summary>
            Map from basic block range to set of writes within this block range.
            Used for try-catch-finally analysis, where start of catch/finally blocks should
            consider all writes in the corresponding try block as reachable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.LValueFlowCapturesInGraph">
            <summary>
            Flow captures for l-value or address captures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.HandleCatchOrFilterOrFinallyInitialization(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,System.Threading.CancellationToken)">
            <summary>
            Special handling to ensure that at start of catch/filter/finally region analysis,
            we mark all symbol writes from the corresponding try region as reachable in the
            catch/filter/finally region.
            </summary>
            <param name="basicBlock"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Walker">
            <summary>
            Operations walker used for walking high-level operation tree
            as well as control flow graph based operations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.SymbolWritesMap">
            <summary>
            Map from each symbol write to a boolean indicating if the value assinged
            at write is used/read on some control flow path.
            For example, consider the following code:
            <code>
                int x = 0;
                x = 1;
                Console.WriteLine(x);
            </code>
            This map will have two entries for 'x':
                1. Key = (symbol: x, write: 'int x = 0')
                   Value = 'false', because value assigned to 'x' here **is never** read. 
                2. Key = (symbol: x, write: 'x = 1')
                   Value = 'true', because value assigned to 'x' here **may be** read on
                   some control flow path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.SymbolsRead">
            <summary>
            Set of locals/parameters that are read at least once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.GetUnreadSymbolWrites">
            <summary>
            Gets symbol writes that have are never read.
            WriteOperation will be null for the initial value write to parameter symbols from the callsite.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.IsInitialParameterValueUsed(Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            Returns true if the initial value of the parameter from the caller is used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.GetSymbolWriteCount(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the write count for a given local/parameter symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.NamingStyleOptions.NamingPreferences">
            <summary>
            This option describes the naming rules that should be applied to specified categories of symbols, 
            and the level to which those rules should be enforced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.AliasAnnotation">
            <summary>
            This annotation will be used by the expansion/reduction to annotate expanded syntax nodes to store the information that an 
            alias was used before expansion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.DoNotAllowVarAnnotation">
            <summary>
            When applied to a SyntaxNode, prevents the simplifier from converting a type to 'var'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SymbolAnnotation">
            <summary>
            An annotation that holds onto information about a type or namespace symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation`1">
            <summary>
            Specifies that an option should be read from an .editorconfig file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation`1.GetEditorConfigStringValue(`0,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            Gets the editorconfig string representation for this storage location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2.GetEditorConfigString(System.Object,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            Gets the editorconfig string representation for this storage location. The result is a complete line of the
            <strong>.editorconfig</strong> file, such as the following:
            <code>
            dotnet_sort_system_directives_first = true
            </code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2.GetEditorConfigStringValue(System.Object,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)">
            <summary>
            Gets the editorconfig string representation for this storage location. The result only includes the value
            for the <strong>.editorconfig</strong> entry.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2.GetEditorConfigString(System.Object,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOption2">
            <summary>
            Internal base option type that is available in both the Workspaces layer and CodeStyle layer.
            Its definition in Workspaces layer sub-types "IOption" and its definition in CodeStyle layer
            explicitly defines all the members from "IOption" type as "IOption" is not available in CodeStyle layer.
            This ensures that all the sub-types of <see cref="T:Microsoft.CodeAnalysis.Options.IOption2"/> in either layer see an identical
            set of interface members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOptionWithGroup">
            <summary>
            Group/sub-feature associated with an <see cref="T:Microsoft.CodeAnalysis.Options.IOption2"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.IOptionWithGroup.Group">
            <summary>
            Group/sub-feature for this option.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.LocalUserProfileStorageLocation">
            <summary>
            Specifies that the option should be stored into the user's local registry hive.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionGroup">
            <summary>
            Group/sub-feature associated with an option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Description">
            <summary>
            A localizable resource description string for the option group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Priority">
            <summary>
            Relative priority of the option group with respect to other option groups within the same feature.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Feature">
            <summary>
            Feature this option is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Group">
            <summary>
            Optional group/sub-feature for this option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Name">
            <summary>
            The name of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.DefaultValue">
            <summary>
            The default value of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Type">
            <summary>
            The type of the option value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.IsPerLanguage">
            <summary>
            Flag indicating if this is a per-language option or a language specific option.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionStorageLocation2">
            <summary>
            The base type of all types that specify where options are stored.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption">
            <summary>
            Marker interface for language specific options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption`1">
            <summary>
            Marker interface for language specific options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.Option2`1">
            <summary>
            An global option. An instance of this class can be used to access an option value from an OptionSet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option2`1.Feature">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Feature"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option2`1.Group">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Group"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option2`1.Name">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Name"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option2`1.DefaultValue">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.DefaultValue"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option2`1.Type">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Type"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option2`1.StorageLocations">
            <summary>
            Storage locations for the option.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption">
            <summary>
            Marker interface for <see cref="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption`1">
            <summary>
            Marker interface for <see cref="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1">
            <summary>
            An option that can be specified once per language.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1.Feature">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Feature"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1.Group">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Group"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1.Name">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Name"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1.Type">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Type"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1.DefaultValue">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.DefaultValue"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1.StorageLocations">
            <summary>
            Storage locations for the option.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation">
            <summary>
            Specifies that the option should be stored into a roamed profile across machines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation.#ctor(System.Func{System.String,System.String})">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation"/> that has different key names for different languages.
            </summary>
            <param name="keyNameFromLanguageName">A function that maps from a <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> value to the key name.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSyntaxFacts.SpansPreprocessorDirective(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Determines if there is preprocessor trivia *between* any of the <paramref name="tokens"/>
            provided.  The <paramref name="tokens"/> will be deduped and then ordered by position.
            Specifically, the first token will not have it's leading trivia checked, and the last
            token will not have it's trailing trivia checked.  All other trivia will be checked to
            see if it contains a preprocessor directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSyntaxFacts.TryGetAncestorForLocation``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Tries to get an ancestor of a Token on current position or of Token directly to left:
            e.g.: tokenWithWantedAncestor[||]tokenWithoutWantedAncestor
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISemanticFacts.SupportsImplicitInterfaceImplementation">
            <summary>
            True if this language supports implementing an interface by signature only. If false,
            implementations must specific explicitly which symbol they're implementing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISemanticFacts.ExposesAnonymousFunctionParameterNames">
            <summary>
            True if anonymous functions in this language have signatures that include named
            parameters that can be referenced later on when the function is invoked.  Or, if the
            anonymous function is simply a signature that will be assigned to a delegate, and the
            delegate's parameter names are used when invoking.  
            
            For example, in VB one can do this: 
            
            dim v = Sub(x as Integer) Blah()
            v(x:=4)
            
            However, in C# that would need to be:
            
            Action&lt;int&gt; v = (int x) => Blah();
            v(obj:=4)
            
            Note that in VB one can access 'x' outside of the declaration of the anonymous type.
            While in C# 'x' can only be accessed within the anonymous type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFacts.IsWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: reads may also be performed
            to the expression as well.  For example, "++a".  In this expression 'a' is both read from
            and written to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFacts.IsOnlyWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: unlike IsWrittenTo, this
            will not return true if reads are performed on the expression as well.  For example,
            "++a" will return 'false'.  However, 'a' in "out a" or "a = 1" will return true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFacts.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            return speculative semantic model for supported node. otherwise, it will return null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFacts.GetAliasNameSet(Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            get all alias names defined in the semantic model
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
             <summary>
             Returns 'true' if this a 'reserved' keyword for the language.  A 'reserved' keyword is a
             identifier that is always treated as being a special keyword, regardless of where it is
             found in the token stream.  Examples of this are tokens like <see langword="class"/> and
             <see langword="Class"/> in C# and VB respectively.
            
             Importantly, this does *not* include contextual keywords.  If contextual keywords are
             important for your scenario, use <see cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)"/> or <see
             cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsExtensions.IsReservedOrContextualKeyword(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxToken)"/>.  Also, consider using
             <see cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsExtensions.IsWord(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxToken)"/> if all you need is the ability to know
             if this is effectively any identifier in the language, regardless of whether the language
             is treating it as a keyword or not.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
             <summary>
             Returns <see langword="true"/> if this a 'contextual' keyword for the language.  A
             'contextual' keyword is a identifier that is only treated as being a special keyword in
             certain *syntactic* contexts.  Examples of this is 'yield' in C#.  This is only a
             keyword if used as 'yield return' or 'yield break'.  Importantly, identifiers like <see
             langword="var"/>, <see langword="dynamic"/> and <see langword="nameof"/> are *not*
             'contextual' keywords.  This is because they are not treated as keywords depending on
             the syntactic context around them.  Instead, the language always treats them identifiers
             that have special *semantic* meaning if they end up not binding to an existing symbol.
            
             Importantly, if <paramref name="token"/> is not in the syntactic construct where the
             language thinks an identifier should be contextually treated as a keyword, then this
             will return <see langword="false"/>.
            
             Or, in other words, the parser must be able to identify these cases in order to be a
             contextual keyword.  If identification happens afterwards, it's not contextual.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            The set of identifiers that have special meaning directly after the `#` token in a
            preprocessor directive.  For example `if` or `pragma`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetLeftSideOfDot(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Get the node on the left side of the dot if given a dotted expression.
            </summary>
            <param name="allowImplicitTarget">
            In VB, we have a member access expression with a null expression, this may be one of the
            following forms:
                1) new With { .a = 1, .b = .a      .a refers to the anonymous type
                2) With obj : .m                   .m refers to the obj type
                3) new T() With { .a = 1, .b = .a  'a refers to the T type
            If `allowImplicitTarget` is set to true, the returned node will be set to approperiate node, otherwise, it will return null.
            This parameter has no affect on C# node.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetStandaloneExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetRootConditionalAccessExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Call on the `.y` part of a `x?.y` to get the entire `x?.y` conditional access expression.  This also works
            when there are multiple chained conditional accesses.  For example, calling this on '.y' or '.z' in
            `x?.y?.z` will both return the full `x?.y?.z` node.  This can be used to effectively get 'out' of the RHS of
            a conditional access, and commonly represents the full standalone expression that can be operated on
            atomically.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetExpressionOfMemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns the expression node the member is being accessed off of.  If <paramref name="allowImplicitTarget"/>
            is <see langword="false"/>, this will be the node directly to the left of the dot-token.  If <paramref name="allowImplicitTarget"/>
            is <see langword="true"/>, then this can return another node in the tree that the member will be accessed
            off of.  For example, in VB, if you have a member-access-expression of the form ".Length" then this
            may return the expression in the surrounding With-statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsSimpleArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if this is an argument with just an expression and nothing else (i.e. no ref/out,
            no named params, no omitted args).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsMethodBody(Microsoft.CodeAnalysis.SyntaxNode)">
             <summary>
             Returns true for nodes that represent the body of a method.
            
             For VB this will be
             MethodBlockBaseSyntax.  This will be true for things like constructor, method, operator
             bodies as well as accessor bodies.  It will not be true for things like sub() function()
             lambdas.
            
             For C# this will be the BlockSyntax or ArrowExpressionSyntax for a
             method/constructor/deconstructor/operator/accessor.  It will not be included for local
             functions.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsTypeCharacter(System.Char)">
            <summary>
            Returns true if the given character is a character which may be included in an
            identifier to specify the type of a variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsScopeBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A block that has no semantics other than introducing a new scope. That is only C# BlockSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsExecutableBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A node that contains a list of statements. In C#, this is BlockSyntax and SwitchSectionSyntax.
            In VB, this includes all block statements such as a MultiLineIfBlockSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsStatementContainer(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A node that can host a list of statements or a single statement. In addition to
            every "executable block", this also includes C# embedded statement owners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetMemberBodySpanForSpeculativeBinding(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, return the <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> representing the span of the member body
            it is contained within. This <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> is used to determine whether speculative binding should be
            used in performance-critical typing scenarios. Note: if this method fails to find a relevant span, it returns
            an empty <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> at position 0.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.TryGetBindableParent(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns the parent node that binds to the symbols that the IDE prefers for features like Quick Info and Find
            All References. For example, if the token is part of the type of an object creation, the parenting object
            creation expression is returned so that binding will return constructor symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetNameForArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, that represents and argument return the string representation of
            that arguments name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetNameForAttributeArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, that represents an attribute argument return the string representation of
            that arguments name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.IsOnTypeHeader(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            <paramref name="fullHeader"/> controls how much of the type header should be considered. If <see
            langword="false"/> only the span up through the type name will be considered.  If <see langword="true"/>
            then the span through the base-list will be considered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetAccessibility(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the accessibility of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetDeclarationKind(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Internal.Editing.DeclarationKind"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsExtensions.IsOnTypeHeader(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Checks if the position is on the header of a type (from the start of the type up through it's name).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsExtensions.GetStatementContainer(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statement container node for the statement <paramref name="node"/>.
            </summary>
            <param name="syntaxFacts">The <see cref="T:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts"/> implementation.</param>
            <param name="node">The statement.</param>
            <returns>The statement container for <paramref name="node"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsExtensions.GetRootStandaloneExpression(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Similar to <see cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetStandaloneExpression(Microsoft.CodeAnalysis.SyntaxNode)"/>, this gets the containing
            expression that is actually a language expression and not just typed as an ExpressionSyntax for convenience.
            However, this goes beyond that that method in that if this expression is the RHS of a conditional access
            (i.e. <c>a?.b()</c>) it will also return the root of the conditional access expression tree.
            <para/> The intuition here is that this will give the topmost expression node that could realistically be
            replaced with any other expression.  For example, with <c>a?.b()</c> technically <c>.b()</c> is an
            expression.  But that cannot be replaced with something like <c>(1 + 1)</c> (as <c>a?.(1 + 1)</c> is not
            legal).  However, in <c>a?.b()</c>, then <c>a</c> itself could be replaced with <c>(1 + 1)?.b()</c> to form
            a legal expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds">
            <summary>
            Provides a uniform view of SyntaxKinds over C# and VB for constructs they have
            in common.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.MultiLineCommentTrivia">
            <summary>
            Gets the syntax kind for a multi-line comment.
            </summary>
            <value>
            The raw syntax kind for a multi-line comment; otherwise, <see langword="null"/> if the language does not
            support multi-line comments.
            </value>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PublicContract">
            <summary>
            Helpers used for public API argument validation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PublicContract.ToBoxedImmutableArrayWithNonNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Use to validate public API input for properties that are exposed as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PublicContract.ToBoxedImmutableArrayWithDistinctNonNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Use to validate public API input for properties that are exposed as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and 
            whose items should be unique.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SerializableBytes">
            <summary>
            Helpers to create temporary streams backed by pooled memory
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1">
            <summary>
            This class is a <see cref="T:Roslyn.Utilities.ValueSource`1"/> that holds onto a value weakly, 
            but can save its value and recover it on demand if needed.
            
            The initial value comes from the <see cref="T:Roslyn.Utilities.ValueSource`1"/> specified in the constructor.
            Derived types implement SaveAsync and RecoverAsync.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1.SaveAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Override this to save the state of the instance so it can be recovered.
            This method will only ever be called once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1.RecoverAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method to implement asynchronous recovery semantics.
            This method may be called multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1.Recover(System.Threading.CancellationToken)">
            <summary>
            Override this method to implement synchronous recovery semantics.
            This method may be called multiple times.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WeaklyCachedValueSource`1">
            <summary>
            A value source that caches its value weakly once obtained from its source.
            The source must allow repeatable accesses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.GetValueUsageInfo(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.ValueUsageInfo"/> for the given operation.
            This extension can be removed once https://github.com/dotnet/roslyn/issues/25057 is implemented.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.IsAnyCompoundAssignment(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Retursn true if the given operation is a regular compound assignment,
            i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/> such as <code>a += b</code>,
            or a special null coalescing compoud assignment, i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation"/>
            such as <code>a ??= b</code>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolUsageInfo">
            <summary>
            Provides information about the way a particular symbol is being used at a symbol reference node.
            For namespaces and types, this corresponds to values from <see cref="T:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo"/>.
            For methods, fields, properties, events, locals and parameters, this corresponds to values from <see cref="T:Microsoft.CodeAnalysis.ValueUsageInfo"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Qualified">
            <summary>
            Represents a reference to a namespace or type on the left side of a dotted name (qualified name or member access).
            For example, 'NS' in <code>NS.Type x = new NS.Type();</code> or <code>NS.Type.StaticMethod();</code> or 
            'Type' in <code>Type.NestedType x = new Type.NestedType();</code> or <code>Type.StaticMethod();</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.TypeArgument">
            <summary>
            Represents a generic type argument reference.
            For example, 'Type' in <code>Generic{Type} x = ...;</code> or <code>class Derived : Base{Type} { }</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.TypeConstraint">
            <summary>
            Represents a type parameter constraint that is a type.
            For example, 'Type' in <code>class Derived{T} where T : Type { }</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Base">
            <summary>
            Represents a base type or interface reference in the base list of a named type.
            For example, 'Base' in <code>class Derived : Base { }</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.ObjectCreation">
            <summary>
            Represents a reference to a type whose instance is being created.
            For example, 'C' in <code>var x = new C();</code>, where 'C' is a named type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Import">
            <summary>
            Represents a reference to a namespace or type within a using or imports directive.
            For example, <code>using NS;</code> or <code>using static NS.Extensions</code> or <code>using Alias = MyType</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.NamespaceDeclaration">
            <summary>
            Represents a reference to a namespace name in a namespace declaration context.
            For example, 'N1' or <code>namespaces N1.N2 { }</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Read">
            <summary>
            Represents a value read.
            For example, reading the value of a local/field/parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Write">
            <summary>
            Represents a value write.
            For example, assigning a value to a local/field/parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Reference">
            <summary>
            Represents a reference being taken for the symbol.
            For example, passing an argument to an "in", "ref" or "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Name">
            <summary>
            Represents a name-only reference that neither reads nor writes the underlying value.
            For example, 'nameof(x)' or reference to a symbol 'x' in a documentation comment
            does not read or write the underlying value stored in 'x'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadWrite">
            <summary>
            Represents a value read and/or write.
            For example, an increment or compound assignment operation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "in" or "ref readonly" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.WritableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadableWritableReference">
            <summary>
            Represents a value read or write.
            For example, passing an argument to a "ref" parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SharedPools">
            <summary>
            Shared object pool for roslyn
            
            Use this shared pool if only concern is reducing object allocations.
            if perf of an object pool itself is also a concern, use ObjectPool directly.
            
            For example, if you want to create a million of small objects within a second, 
            use the ObjectPool directly. it should have much less overhead than using this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.StringIgnoreCaseDictionary``1">
            <summary>
            pool that uses string as key with StringComparer.OrdinalIgnoreCase as key comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.StringIgnoreCaseHashSet">
            <summary>
            pool that uses string as element with StringComparer.OrdinalIgnoreCase as element comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.StringHashSet">
            <summary>
            pool that uses string as element with StringComparer.Ordinal as element comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.ByteArray">
            <summary>
            Used to reduce the # of temporary byte[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2.GetDiagnosticSquiggleLocation(`1,System.Threading.CancellationToken)">
            <summary>
            Gets the span of text to squiggle underline.
            If the expression is contained within a single line, the entire expression span is returned.
            Otherwise it will return the span from the expression start to the end of the same line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.CommentPrefix">
            <summary>
            Gets the text prefix indicating a single-line comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.SingleLineCommentTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.SingleLineCommentTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.MultiLineCommentTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.MultiLineCommentTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.WhitespaceTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.WhitespaceTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.EndOfLineTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKinds.EndOfLineTrivia"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.IndexOfFirstNonWhitespaceTrivia``1(``0)">
            <summary>
            Returns the index of the first non-whitespace trivia in the given trivia list.
            </summary>
            <param name="triviaList">The trivia list to process.</param>
            <typeparam name="T">The type of the trivia list.</typeparam>
            <returns>The index where the non-whitespace starts, or -1 if there is no non-whitespace trivia.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader">
            <summary>
            Contains the parsed file header information for a syntax tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileHeaders.FileHeader._fileHeaderStart">
            <summary>
            The location in the source where the file header was expected to start.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileHeaders.FileHeader._commentPrefixLength">
            <summary>
            The length of the prefix indicating the start of a comment. For example:
            <list type="bullet">
              <item>
                <term>C#</term>
                <description>2, for the length of <c>//</c>.</description>
              </item>
              <item>
                <term>Visual Basic</term>
                <description>1, for the length of <c>'</c>.</description>
              </item>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> struct.
            </summary>
            <param name="copyrightText">The copyright string, as parsed from the header.</param>
            <param name="fileHeaderStart">The offset within the file at which the header started.</param>
            <param name="fileHeaderEnd">The offset within the file at which the header ended.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> struct.
            </summary>
            <param name="fileHeaderStart">The offset within the file at which the header started, or was expected to start.</param>
            <param name="isMissing"><see langword="true"/> if the file header is missing; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.FileHeader.IsMissing">
            <summary>
            Gets a value indicating whether the file header is missing.
            </summary>
            <value>
            <see langword="true"/> if the file header is missing; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.FileHeader.CopyrightText">
            <summary>
            Gets the copyright text, as parsed from the header.
            </summary>
            <value>
            The copyright text, as parsed from the header.
            </value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.MissingFileHeader(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> instance representing a missing file header starting at the specified
            position.
            </summary>
            <param name="fileHeaderStart">The location at which a file header was expected. This will typically be the
            start of the first line after any directive trivia (<see cref="P:Microsoft.CodeAnalysis.SyntaxTrivia.IsDirective"/>) to account for
            source suppressions.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> instance representing a missing file header.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.GetLocation(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the location representing the start of the file header.
            </summary>
            <param name="syntaxTree">The syntax tree to use for generating the location.</param>
            <returns>The location representing the start of the file header.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersHelpers._lastParsed">
            <remarks>
            Reference type so we can read/write atomically.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessDiagnosticAnalyzer`3.CanMemberAccessBeQualified(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Reports on whether the specified member is suitable for qualification. Some member
            access expressions cannot be qualified; for instance if they begin with <c>base.</c>,
            <c>MyBase.</c>, or <c>MyClass.</c>.
            </summary>
            <returns>True if the member access can be qualified; otherwise, False.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`2.HandleNamedTypeSymbolStart(Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext,System.Action{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ValueUsageInfo})">
            <summary>
            Override this method to register custom language specific actions to find symbol usages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`2.CompilationAnalyzer.IsCandidateSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the given symbol meets the following criteria to be
            a candidate for dead code analysis:
                1. It is marked as "private".
                2. It is not an implicitly declared symbol.
                3. It is either a method, field, property or an event.
                4. If method, then it is a constructor OR a method with <see cref="F:Microsoft.CodeAnalysis.MethodKind.Ordinary"/>,
                   such that is meets a few criteria (see implementation details below).
                5. If field, then it must not be a backing field for an auto property.
                   Backing fields have a non-null <see cref="P:Microsoft.CodeAnalysis.IFieldSymbol.AssociatedSymbol"/>.
                6. If property, then it must not be an explicit interface property implementation.
                7. If event, then it must not be an explicit interface event implementation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer">
            <summary>
            Analyzer to report unused expression values and parameters:
            It flags the following cases:
                1. Expression statements that drop computed value, for example, "Computation();".
                   These should either be removed (redundant computation) or should be replaced
                   with explicit assignment to discard variable OR an unused local variable,
                   i.e. "_ = Computation();" or "var unused = Computation();"
                   This diagnostic configuration is controlled by language specific code style option "UnusedValueExpressionStatement".
                2. Value assignments to locals/parameters that are never used on any control flow path,
                   For example, value assigned to 'x' in first statement below is unused and will be flagged:
                        x = Computation();
                        if (...)
                            x = Computation2();
                        else
                            Computation3(out x);
                        ... = x;
                   Just as for case 1., these should either be removed (redundant computation) or
                   should be replaced with explicit assignment to discard variable OR an unused local variable,
                   i.e. "_ = Computation();" or "var unused = Computation();"
                   This diagnostic configuration is controlled by language specific code style option "UnusedValueAssignment".
                3. Redundant parameters that fall into one of the following two categories:
                    a. Have no references in the executable code block(s) for its containing method symbol.
                    b. Have one or more references but its initial value at start of code block is never used.
                       For example, if 'x' in the example for case 2. above was a parameter symbol with RefKind.None
                       and "x = Computation();" is the first statement in the method body, then its initial value
                       is never used. Such a parameter should be removed and 'x' should be converted into a local.
                   We provide additional information in the diagnostic message to clarify the above two categories
                   and also detect and mention about potential breaking change if the containing method is a public API.
                   Currently, we do not provide any code fix for removing unused parameters as it needs fixing the
                   call sites and any automated fix can lead to subtle overload resolution differences,
                   though this may change in future.
                   This diagnostic configuration is controlled by <see cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.UnusedParameters"/> option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.ShouldBailOutFromRemovableAssignmentAnalysis(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Indicates if we should bail from removable assignment analysis for the given
            symbol write operation.
            Removable assignment analysis determines if the assigned value for the symbol write
            has no side effects and can be removed without changing the semantics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsCallStatement(Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation)">
            <summary>
            Indicates if the given expression statement operation has an explicit "Call" statement syntax indicating explicit discard.
            For example, VB "Call" statement.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsExpressionOfExpressionBody(Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation)">
            <summary>
            Indicates if the given operation is an expression of an expression body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.CreatePropertiesMap">
            <summary>
            Method to compute well-known diagnostic property maps for different comnbinations of diagnostic properties.
            The property map is added to each instance of the reported diagnostic and is used by the code fixer to
            compute the correct code fix.
            It currently maps to three different properties of the diagnostic:
                1. The underlying <see cref="T:Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference"/> for the reported diagnostic
                2. "isUnusedLocalAssignment": Flag indicating if the flagged local variable has no reads/uses.
                3. "isRemovableAssignment": Flag indicating if the assigned value is from an expression that has no side effects
                        and hence can be removed completely. For example, if the assigned value is a constant or a reference
                        to a local/parameter, then it has no side effects, but if it is method invocation, it may have side effects.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasDelegateCreationOrAnonymousFunction">
            <summary>
            Indicates if the operation block has an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasDelegateEscape">
            <summary>
            Indicates if the operation block has an operation that leads to a delegate escaping the current block,
            which would prevent us from performing accurate flow analysis of lambda/local function invocations
            within this operation block.
            Some examples:
                1. Delegate assigned to a field or property.
                2. Delegate passed as an argument to an invocation or object creation.
                3. Delegate added to an array or wrapped within a tuple.
                4. Delegate converted to a non-delegate type.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasInvalidOperation">
            <summary>
            Indicates if the operation block has an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation"/>.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._referencedParameters">
            <summary>
            Parameters which have at least one read/write reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.IsHandledDelegateCreationOrAnonymousFunctionTreeShape(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            We handle only certain operation tree shapes in flow analysis
            when delegate creations are involved (lambdas/local functions).
            We track assignments of lambdas/local functions to parameters/locals,
            assignments of parameters/locals to other parameters/locals of delegate types,
            and then delegate invocations through parameter/locals.
            For the remaining unknown ones, we conservatively mark the operation as leading to
            delegate escape, and corresponding bail out from flow analysis in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/>.
            This function checks the operation tree shape in context of
            an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.IsHandledLocalOrParameterReferenceTreeShape(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            We handle only certain operation tree shapes in flow analysis
            when delegate creations are involved (lambdas/local functions).
            We track assignments of lambdas/local functions to parameters/locals,
            assignments of parameters/locals to other parameters/locals of delegate types,
            and then delegate invocations through parameter/locals.
            For the remaining unknown ones, we conservatively mark the operation as leading to
            delegate escape, and corresponding bail out from flow analysis in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/>.
            This function checks the operation tree shape in context of
            an <see cref="T:Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation"/>
            of delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)">
            <summary>
            Method invoked in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.AnalyzeOperationBlockEnd(Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext)"/>
            for each operation block to determine if we should analyze the operation block or bail out.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer._unusedParameters">
            <summary>
            Map from unused parameters to a boolean value indicating if the parameter has a read reference or not.
            For example, a parameter whose initial value is overwritten before any reads
            is an unused parameter with read reference(s).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionDiagnosticAnalyzer`4">
            <summary>
            Looks for code of the form "x == null ? y : x" and offers to convert it to "x ?? y";
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3._binaryToAssignmentMap">
            <summary>
            Maps from a binary expression kind (like AddExpression) to the corresponding assignment
            form (like AddAssignmentExpression).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers.UnwrapSingleStatementBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Will unwrap a block with a single statement in it to just that block.  Used so we can
            support both <c>if (expr) { statement }</c> and <c>if (expr) statement</c>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer">
            <summary>
            Helper code to support both "UseSystemHashCodeCodeFixProvider" and
            <see cref="T:Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeDiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.GetHashedMembers(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Analyzes the containing <c>GetHashCode</c> method to determine which fields and
            properties were combined to form a hash code for this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.IsLiteralNumber(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Matches positive and negative numeric literals.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.OperationDeconstructor">
            <summary>
            Breaks down complex <see cref="T:Microsoft.CodeAnalysis.IOperation"/> trees, looking for particular
            <see cref="M:System.Object.GetHashCode"/> patterns and extracting out the field and property
            symbols use to compute the hash.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseSystemHashCode.Analyzer.OperationDeconstructor.TryAddHashedSymbol(Microsoft.CodeAnalysis.IOperation,System.Boolean)">
            <summary>
            Recursive function that decomposes <paramref name="value"/>, looking for particular
            forms that VS or ReSharper generate to hash fields in the containing type.
            </summary>
            <param name="seenHash">'seenHash' is used to determine if we actually saw something
            that indicates that we really hashed a field/property and weren't just simply
            referencing it.  This is used as we recurse down to make sure we've seen a
            pattern we explicitly recognize by the time we hit a field/prop.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseThrowExpression.AbstractUseThrowExpressionDiagnosticAnalyzer">
             <summary>
             Looks for patterns of the form:
             <code>
             if (a == null) {
               throw SomeException();
             }
            
             x = a;
             </code>
            
             and offers to change it to
            
             <code>
             x = a ?? throw SomeException();
             </code>
            
             Note: this analyzer can be updated to run on VB once VB supports 'throw'
             expressions as well.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.s_removeEscapedBracketsRegex">
            <summary>
            this regex is used to remove escaped brackets from
            the format string before looking for valid {} pairs
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.s_extractPlaceholdersRegex">
            <summary>
            this regex is used to extract the text between the
            brackets and save the contents in a MatchCollection
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.RemoveEscapedBrackets(System.String)">
            <summary>
            removing escaped left brackets and replacing with space characters so they won't
            impede the extraction of placeholders, yet the locations of the placeholders are
            the same as in the original string.
            </summary>
            <param name="formatString"></param>
            <returns>string with left brackets removed and replaced by spaces</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.A_language_name_cannot_be_specified_for_this_option">
            <summary>A language name cannot be specified for this option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.A_language_name_must_be_specified_for_this_option">
            <summary>A language name must be specified for this option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Error">
            <summary>Error</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Fix_formatting">
            <summary>Fix formatting</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Indentation_and_spacing">
            <summary>Indentation and spacing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.New_line_preferences">
            <summary>New line preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.None">
            <summary>None</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Refactoring_Only">
            <summary>Refactoring Only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Suggestion">
            <summary>Suggestion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Warning">
            <summary>Warning</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Arrays_with_more_than_one_dimension_cannot_be_serialized">
            <summary>Arrays with more than one dimension cannot be serialized.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
            <summary>Value too large to be represented as a 30 bit unsigned integer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.The_type_0_is_not_understood_by_the_serialization_binder">
            <summary>The type '{0}' is not understood by the serialization binder.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Cannot_serialize_type_0">
            <summary>Cannot serialize type '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Deserialization_reader_for_0_read_incorrect_number_of_values">
            <summary>Deserialization reader for '{0}' read incorrect number of values.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyleResources.Stream_is_too_long">
            <summary>Stream is too long.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Absolute_path_expected">
            <summary>Absolute path expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.An_element_with_the_same_key_but_a_different_value_already_exists">
            <summary>An element with the same key but a different value already exists.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Organize_usings">
            <summary>Organize usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.this_dot_and_Me_dot_preferences">
            <summary>this. and Me. preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Language_keywords_vs_BCL_types_preferences">
            <summary>Language keywords vs BCL types preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Parentheses_preferences">
            <summary>Parentheses preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Modifier_preferences">
            <summary>Modifier preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Expression_level_preferences">
            <summary>Expression-level preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Field_preferences">
            <summary>Field preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Parameter_preferences">
            <summary>Parameter preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Suppression_preferences">
            <summary>Suppression preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Pascal_Case">
            <summary>Pascal Case</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Abstract_Method">
            <summary>Abstract Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Begins_with_I">
            <summary>Begins with I</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Class">
            <summary>Class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Delegate">
            <summary>Delegate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Enum">
            <summary>Enum</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Event">
            <summary>Event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Interface">
            <summary>Interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Non_Field_Members">
            <summary>Non-Field Members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Private_Method">
            <summary>Private Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Private_or_Internal_Field">
            <summary>Private or Internal Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Private_or_Internal_Static_Field">
            <summary>Private or Internal Static Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Property">
            <summary>Property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Public_or_Protected_Field">
            <summary>Public or Protected Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Static_Field">
            <summary>Static Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Static_Method">
            <summary>Static Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Struct">
            <summary>Struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Types">
            <summary>Types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Method">
            <summary>Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Missing_prefix_colon_0">
            <summary>Missing prefix: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Missing_suffix_colon_0">
            <summary>Missing suffix: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Prefix_0_does_not_match_expected_prefix_1">
            <summary>Prefix '{0}' does not match expected prefix '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Prefix_0_is_not_expected">
            <summary>Prefix '{0}' is not expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
            <summary>These non-leading words must begin with an upper case letter: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
            <summary>These non-leading words must begin with a lowercase letter: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_words_cannot_contain_lower_case_characters_colon_0">
            <summary>These words cannot contain lower case characters: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_words_cannot_contain_upper_case_characters_colon_0">
            <summary>These words cannot contain upper case characters: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_words_must_begin_with_upper_case_characters_colon_0">
            <summary>These words must begin with upper case characters: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.The_first_word_0_must_begin_with_an_upper_case_character">
            <summary>The first word, '{0}', must begin with an upper case character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.The_first_word_0_must_begin_with_a_lower_case_character">
            <summary>The first word, '{0}', must begin with a lower case character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Cast_is_redundant">
            <summary>Cast is redundant.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Naming_styles">
            <summary>Naming styles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Naming_rules">
            <summary>Naming rules</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Symbol_specifications">
            <summary>Symbol specifications</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Specified_sequence_has_duplicate_items">
            <summary>Specified sequence has duplicate items</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Segment_size_must_be_power_of_2_greater_than_1">
            <summary>Segment size must be power of 2 greater than 1</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_Unnecessary_Cast">
            <summary>Remove Unnecessary Cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_member">
            <summary>Remove unused member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_member_0_is_unused">
            <summary>Private member '{0}' is unused.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_private_members">
            <summary>Remove unused private members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unread_private_members">
            <summary>Remove unread private members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read">
            <summary>Private member '{0}' can be removed as the value assigned to it is never read.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_method_0_can_be_removed_as_it_is_never_invoked">
            <summary>Private method '{0}' can be removed as it is never invoked.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked">
            <summary>Private property '{0}' can be converted to a method as its get accessor is never invoked.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.A_source_file_is_missing_a_required_header">
            <summary>A source file is missing a required header.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.The_file_header_is_missing_or_not_located_at_the_top_of_the_file">
            <summary>The file header is missing or not located at the top of the file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.A_source_file_contains_a_header_that_does_not_match_the_required_text">
            <summary>A source file contains a header that does not match the required text</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.The_file_header_does_not_match_the_required_text">
            <summary>The file header does not match the required text</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_throw_expression">
            <summary>Use 'throw' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_this_or_Me_qualification">
            <summary>Add 'this' or 'Me' qualification.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Member_access_should_be_qualified">
            <summary>Member access should be qualified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Null_check_can_be_simplified">
            <summary>Null check can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_collection_initialization">
            <summary>Simplify collection initialization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Collection_initialization_can_be_simplified">
            <summary>Collection initialization can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_object_initialization">
            <summary>Simplify object initialization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Object_initialization_can_be_simplified">
            <summary>Object initialization can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_readonly_modifier">
            <summary>Add readonly modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Make_field_readonly">
            <summary>Make field readonly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Naming_rule_violation_0">
            <summary>Naming rule violation: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Naming_Styles">
            <summary>Naming Styles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_missing_cases">
            <summary>Add missing cases</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Populate_switch">
            <summary>Populate switch</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Modifiers_are_not_ordered">
            <summary>Modifiers are not ordered</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Order_modifiers">
            <summary>Order modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Expression_value_is_never_used">
            <summary>Expression value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Unnecessary_assignment_of_a_value_to_0">
            <summary>Unnecessary assignment of a value to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Unnecessary_assignment_of_a_value">
            <summary>Unnecessary assignment of a value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc">
            <summary>Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name sta ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter">
            <summary>Remove unused parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter_0">
            <summary>Remove unused parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names">
            <summary>Avoid unused parameters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API">
            <summary>Remove unused parameter '{0}' if it is not part of a shipped public API</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used">
            <summary>Parameter '{0}' can be removed if it is not part of a shipped public API; its initial value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parameter_0_can_be_removed_its_initial_value_is_never_used">
            <summary>Parameter '{0}' can be removed; its initial value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_accessibility_modifiers">
            <summary>Add accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Accessibility_modifiers_required">
            <summary>Accessibility modifiers required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Convert_to_conditional_expression">
            <summary>Convert to conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_coalesce_expression">
            <summary>Use coalesce expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime">
            <summary>Changes to expression trees may result in behavior changes at runtime</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parentheses_can_be_removed">
            <summary>Parentheses can be removed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unnecessary_parentheses">
            <summary>Remove unnecessary parentheses</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_parentheses_for_clarity">
            <summary>Add parentheses for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parentheses_should_be_added_for_clarity">
            <summary>Parentheses should be added for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Prefer_explicitly_provided_tuple_element_name">
            <summary>Prefer explicitly provided tuple element name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_explicitly_provided_tuple_name">
            <summary>Use explicitly provided tuple name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_System_HashCode">
            <summary>Use 'System.HashCode'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.GetHashCode_implementation_can_be_simplified">
            <summary>'GetHashCode' implementation can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_compound_assignment">
            <summary>Use compound assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_null_propagation">
            <summary>Use null propagation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_inferred_member_name">
            <summary>Use inferred member name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Member_name_can_be_simplified">
            <summary>Member name can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Interpolation_can_be_simplified">
            <summary>Interpolation can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_interpolation">
            <summary>Simplify interpolation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_auto_property">
            <summary>Use auto property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Format_string_contains_invalid_placeholder">
            <summary>Format string contains invalid placeholder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_format_string">
            <summary>Invalid format string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Convert_to_tuple">
            <summary>Convert to tuple</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_conditional_expression">
            <summary>Simplify conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Conditional_expression_can_be_simplified">
            <summary>Conditional expression can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_global_SuppressMessageAttribute">
            <summary>Invalid global 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_scope_for_SuppressMessageAttribute">
            <summary>Invalid scope for 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_or_missing_target_for_SuppressMessageAttribute">
            <summary>Invalid or missing target for 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_legacy_format_target_in_SuppressMessageAttribute">
            <summary>Avoid legacy format target in 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_legacy_format_target_0_in_SuppressMessageAttribute">
            <summary>Avoid legacy format target '{0}' in 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unnecessary_suppression">
            <summary>Remove unnecessary suppression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_redundant_equality">
            <summary>Remove redundant equality</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_decrement_operator">
            <summary>Use '--' operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_increment_operator">
            <summary>Use '++' operator</summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentDictionaryExtensions.Add``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            NOTE!!! adding duplicates will result in exceptions. 
            Being concurrent only allows accessing the dictionary without taking locks.
            Duplicate keys are still not allowed in the hashtable.
            If unsure about adding unique items use APIs such as TryAdd, GetOrAdd, etc...
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConfiguredYieldAwaitable">
            <summary>
            A custom awaiter that supports <see cref="M:Roslyn.Utilities.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)"/> for
            <see cref="M:System.Threading.Tasks.Task.Yield"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exactly one, and default(TSource) otherwise.
            Unlike <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.Functions`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Roslyn.Utilities.Predicates`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(System.Object)">
            <summary>
            Creates an <see cref="T:System.InvalidOperationException"/> with information about an unexpected value.
            </summary>
            <param name="o">The unexpected value.</param>
            <returns>The <see cref="T:System.InvalidOperationException"/>, which should be thrown by the caller.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ValueTaskFactory">
            <summary>
            Implements <see cref="T:System.Threading.Tasks.ValueTask"/> and <see cref="T:System.Threading.Tasks.ValueTask`1"/> static members that are only available in .NET 5.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)">
            <summary>
            Implements <c>ConfigureAwait(bool)</c> for <see cref="M:System.Threading.Tasks.Task.Yield"/>. The resulting behavior in asynchronous code
            is the same as one would expect for <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/>.
            </summary>
            <param name="awaitable">The awaitable provided by <see cref="M:System.Threading.Tasks.Task.Yield"/>.</param>
            <param name="continueOnCapturedContext"><inheritdoc cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/></param>
            <returns>An object used to await this yield.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="T:Roslyn.Utilities.IObjectWritable">
            <summary>
            Objects that implement this interface know how to write their contents to an <see cref="T:Roslyn.Utilities.ObjectWriter"/>,
            so they can be reconstructed later by an <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization">
            <summary>
            Returns 'true' when the same instance could be used more than once.
            Instances that return 'false' should not be tracked for the purpose 
            of de-duplication while serializing/deserializing.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectBinder">
            <summary>
            <see cref="T:Roslyn.Utilities.ObjectBinder"/> is a registry that maps between arbitrary <see cref="T:System.Type"/>s and 
            the 'reader' function used to deserialize serialized instances of those types.  Registration
            must happen ahead of time using the <see cref="M:Roslyn.Utilities.ObjectBinder.RegisterTypeReader(System.Type,System.Func{Roslyn.Utilities.ObjectReader,Roslyn.Utilities.IObjectWritable})"/> method.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_gate">
            <summary>
            Lock for all data in this type.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_lastSnapshot">
            <summary>
            Last created snapshot of our data.  We hand this out instead of exposing our raw
            data so that <see cref="T:Roslyn.Utilities.ObjectReader"/> and <see cref="T:Roslyn.Utilities.ObjectWriter"/> do not need to
            take any locks while processing.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_typeToIndex">
            <summary>
            Map from a <see cref="T:System.Type"/> to the corresponding index in <see cref="F:Roslyn.Utilities.ObjectBinder.s_types"/> and
            <see cref="F:Roslyn.Utilities.ObjectBinder.s_typeReaders"/>.  <see cref="T:Roslyn.Utilities.ObjectWriter"/> will write out the index into
            the stream, and <see cref="T:Roslyn.Utilities.ObjectReader"/> will use that index to get the reader used
            for deserialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectBinder.GetSnapshot">
            <summary>
            Gets an immutable copy of the state of this binder.  This copy does not need to be
            locked while it is used.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectReader"/> that deserializes objects from a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader.VersionByte1">
            <summary>
            We start the version at something reasonably random.  That way an older file, with 
            some random start-bytes, has little chance of matching our version.  When incrementing
            this version, just change VersionByte2.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._objectReferenceMap">
            <summary>
            Map of reference id's to deserialized objects.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Roslyn.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Roslyn.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
            <param name="stream">The stream to read objects from.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Attempts to create a <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            If the <paramref name="stream"/> does not start with a valid header, then <see langword="null"/> will
            be returned.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.GetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            Unlike <see cref="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)"/>, it requires the version
            of the data in the stream to exactly match the current format version.
            Should only be used to read data written by the same version of Roslyn.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader.ReaderReferenceMap`1">
            <summary>
            A reference-id to object map, that can share base data efficiently.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectWriter"/> that serializes objects to a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._objectReferenceMap">
            <summary>
            Map of serialized object's reference ids.  The object-reference-map uses reference equality
            for performance.  While the string-reference-map uses value-equality for greater cache hits 
            and reuse.
            
            These are not readonly because they're structs and we mutate them.
            
            When we write out objects/strings we give each successive, unique, item a monotonically 
            increasing integral ID starting at 0.  I.e. the first object gets ID-0, the next gets 
            ID-1 and so on and so forth.  We do *not* include these IDs with the object when it is
            written out.  We only include the ID if we hit the object *again* while writing.
            
            During reading, the reader knows to give each object it reads the same monotonically 
            increasing integral value.  i.e. the first object it reads is put into an array at position
            0, the next at position 1, and so on.  Then, when the reader reads in an object-reference
            it can just retrieved it directly from that array.
            
            In other words, writing and reading take advantage of the fact that they know they will
            write and read objects in the exact same order.  So they only need the IDs for references
            and not the objects themselves because the ID is inferred from the order the object is
            written or read in.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Roslyn.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Roslyn.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectWriter"/>.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.GuidAccessor">
            <summary>
            Used so we can easily grab the low/high 64bits of a guid for serialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteValue(System.ReadOnlySpan{System.Byte})">
            <summary>
            Write an array of bytes. The array data is provided as a
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan</see>&lt;<see cref="T:System.Byte"/>&gt;, and deserialized to a byte array.
            </summary>
            <param name="span">The array data.</param>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.WriterReferenceMap">
            <summary>
            An object reference to reference-id map, that can share base data efficiently.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.s_reverseTypeMap">
            <summary>
            Indexed by EncodingKind.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.ByteMarkerMask">
            <summary>
            byte marker mask for encoding compressed uint 
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte1Marker">
            <summary>
            byte marker bits for uint encoded in 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte2Marker">
            <summary>
            byte marker bits for uint encoded in 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte4Marker">
            <summary>
            byte marker bits for uint encoded in 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Null">
            <summary>
            The null value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Type">
            <summary>
            A type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Object">
            <summary>
            An object with member values encoded as variants
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_1Byte">
            <summary>
            An object reference with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_2Bytes">
            <summary>
            An object reference with the id encode as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_4Bytes">
            <summary>
            An object reference with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringUtf8">
            <summary>
            A string encoded as UTF8 (using BinaryWriter.Write(string))
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringUtf16">
            <summary>
            A string encoded as UTF16 (as array of UInt16 values)
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_1Byte">
            <summary>
            A reference to a string with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_2Bytes">
            <summary>
            A reference to a string with the id encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_4Bytes">
            <summary>
            A reference to a string with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Boolean_True">
            <summary>
            The boolean value true.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Boolean_False">
            <summary>
            The boolean value char.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Char">
            <summary>
            A character value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int8">
            <summary>
            An Int8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int16">
            <summary>
            An Int16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32">
            <summary>
            An Int32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_1Byte">
            <summary>
            An Int32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_2Bytes">
            <summary>
            An Int32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_0">
            <summary>
            The Int32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_1">
            <summary>
            The Int32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_2">
            <summary>
            The Int32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_3">
            <summary>
            The Int32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_4">
            <summary>
            The Int32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_5">
            <summary>
            The Int32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_6">
            <summary>
            The Int32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_7">
            <summary>
            The Int32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_8">
            <summary>
            The Int32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_9">
            <summary>
            The Int32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_10">
            <summary>
            The Int32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int64">
            <summary>
            An Int64 value encoded as 8 bytes
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt8">
            <summary>
            A UInt8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt16">
            <summary>
            A UIn16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32">
            <summary>
            A UInt32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_1Byte">
            <summary>
            A UInt32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_2Bytes">
            <summary>
            A UInt32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_0">
            <summary>
            The UInt32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_1">
            <summary>
            The UInt32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_2">
            <summary>
            The UInt32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_3">
            <summary>
            The UInt32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_4">
            <summary>
            The UInt32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_5">
            <summary>
            The UInt32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_6">
            <summary>
            The UInt32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_7">
            <summary>
            The UInt32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_8">
            <summary>
            The UInt32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_9">
            <summary>
            The UInt32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_10">
            <summary>
            The UInt32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt64">
            <summary>
            A UInt64 value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Float4">
            <summary>
            A float value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Float8">
            <summary>
            A double value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Decimal">
            <summary>
            A decimal value encoded as 12 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.DateTime">
            <summary>
            A DateTime value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array">
            <summary>
            An array with length encoded as compressed uint
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_0">
            <summary>
            An array with zero elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_1">
            <summary>
            An array with one element
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_2">
            <summary>
            An array with 2 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_3">
            <summary>
            An array with 3 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.BooleanType">
            <summary>
            The boolean type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringType">
            <summary>
            The string type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.EncodingName">
            <summary>
            Encoding serialized as <see cref="P:System.Text.Encoding.WebName"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ArrayExtensions.BinarySearchUpperBound(System.Int32[],System.Int32)">
            <summary>
            Search a sorted integer array for the target value in O(log N) time.
            </summary>
            <param name="array">The array of integers which must be sorted in ascending order.</param>
            <param name="value">The target value.</param>
            <returns>An index in the array pointing to the position where <paramref name="value"/> should be
            inserted in order to maintain the sorted order. All values to the right of this position will be
            strictly greater than <paramref name="value"/>. Note that this may return a position off the end
            of the array if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.CompilerOptionParseUtilities.ParseFeatureFromMSBuild(System.String)">
            <summary>
            Parse the value provided to an MSBuild Feature option into a list of entries.  This will 
            leave name=value in their raw form.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConcurrentSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultConcurrencyLevel">
            <summary>
            The default concurrency level is 2. That means the collection can cope with up to two
            threads making simultaneous modifications without blocking.
            Note ConcurrentDictionary's default concurrency level is dynamic, scaling according to
            the number of processors.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultCapacity">
            <summary>
            Taken from ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1._dictionary">
            <summary>
            The backing dictionary. The values are never used; just the keys.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor">
            <summary>
            Construct a concurrent set with the default concurrency level.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct a concurrent set using the specified equality comparer.
            </summary>
            <param name="equalityComparer">The equality comparer for values in the set.</param>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Contains(`0)">
            <summary>
            Determine whether the given value is in the set.
            </summary>
            <param name="value">The value to test.</param>
            <returns>true if the set contains the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a value to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Clear">
            <summary>
            Clear the set
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.DocumentationCommentXmlNames">
            <summary>
            Names of well-known XML attributes and elements.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(System.Text.Encoding,System.IO.Stream)">
            <summary>
            Get maximum char count needed to decode the entire stream.
            </summary>
            <exception cref="T:System.IO.IOException">Stream is so big that max char count can't fit in <see cref="T:System.Int32"/>.</exception> 
        </member>
        <member name="M:Roslyn.Utilities.EnumUtilities.ConvertEnumUnderlyingTypeToUInt64(System.Object,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.FileNameUtilities">
            <summary>
            Implements a few file name utilities that are needed by the compiler.
            In general the compiler is not supposed to understand the format of the paths.
            In rare cases it needs to check if a string is a valid file name or change the extension 
            (embedded resources, netmodules, output name).
            The APIs are intentionally limited to cover just these rare cases. Do not add more APIs.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name. 
            The name may contain any characters but directory and volume separators.
            </summary>
            <param name="path">Path.</param>
            <returns>
            True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".goo".
            Returns -1 for path "goo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "goo" for path "goo.".
            Returns "goo.." for path "goo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extension changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetFileName(System.String,System.Boolean)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="T:Roslyn.Utilities.SetWithInsertionOrder`1">
            <summary>
            A set that returns the inserted values in insertion order.
            The mutation operations are not thread-safe.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.OneOrMany`1">
            <summary>
            Represents a single item or many items.
            </summary>
            <remarks>
            Used when a collection usually contains a single item but sometimes might contain multiple.
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.PlatformInformation">
            <summary>
            This class provides simple properties for determining whether the current platform is Windows or Unix-based.
            We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
            it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads all bytes from the current position of the given stream to its end.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringTable">
            <summary>
            This is basically a lossy cache of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange})">
             <summary>
             Merges the new change ranges into the old change ranges, adjusting the new ranges to be with respect to the original text
             (with neither old or new changes applied) instead of with respect to the original text after "old changes" are applied.
            
             This may require splitting, concatenation, etc. of individual change ranges.
             </summary>
             <remarks>
             Both `oldChanges` and `newChanges` must contain non-overlapping spans in ascending order.
             </remarks>
        </member>
        <member name="T:Roslyn.Utilities.TextChangeRangeExtensions.UnadjustedNewChange">
            <summary>
            Represents a new change being processed by <see cref="M:Roslyn.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange})"/>.
            Such a new change must be adjusted before being added to the result list.
            </summary>
            <remarks>
            A value of this type may represent the intermediate state of merging of an old change into an unadjusted new change,
            resulting in a temporary unadjusted new change whose <see cref="P:Roslyn.Utilities.TextChangeRangeExtensions.UnadjustedNewChange.SpanStart"/> is negative (not valid) until it is adjusted.
            This tends to happen when we need to merge an old change deletion into a new change near the beginning of the text. (see TextChangeTests.Fuzz_4)
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved or does not exist.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.Stream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLength(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDirectorySeparator(System.Char)">
            <summary>
            True if the character is the platform directory separator character or the alternate directory separator.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(System.Char)">
            <summary>
            True if the character is any recognized directory separator character.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.TrimTrailingSeparators(System.String)">
            <summary>
            Removes trailing directory separator characters
            </summary>
            <remarks>
            This will trim the root directory separator:
            "C:\" maps to "C:", and "/" maps to ""
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.EnsureTrailingSeparator(System.String)">
            <summary>
            Ensures a trailing directory separator character
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it doesn't check for invalid path characters
            </remarks>
            <returns>Prefix of path that represents a directory</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Gets the root part of the path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathKind(System.String)">
            <summary>
            Gets the specific kind of relative or absolute path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAbsolute(System.String)">
            <summary>
            True if the path is an absolute path (rooted to drive or network share)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="root"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ContainsPathComponent(System.String,System.String,System.Boolean)">
            <summary>
            Determines if "path" contains 'component' within itself.
            i.e. asking if the path "c:\goo\bar\baz" has component "bar" would return 'true'.
            On the other hand, if you had "c:\goo\bar1\baz" then it would not have "bar" as a
            component.
            
            A path contains a component if any file name or directory name in the path
            matches 'component'.  As such, if you had something like "\\goo" then that would
            not have "goo" as a component. That's because here "goo" is the server name portion
            of the UNC path, and not an actual directory or file name.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetRelativePath(System.String,System.String)">
            <summary>
            Gets a path relative to a directory.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsChildPath(System.String,System.String)">
            <summary>
            True if the child path is a child of the parent path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String)">
            <summary>
            True if the two paths are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String,System.Int32)">
            <summary>
            True if the two paths are the same.  (but only up to the specified length)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsValidFilePath(System.String)">
            <summary>
            Unfortunately, we cannot depend on Path.GetInvalidPathChars() or Path.GetInvalidFileNameChars()
            From MSDN: The array returned from this method is not guaranteed to contain the complete set of characters
            that are invalid in file and directory names. The full set of invalid characters can vary by file system.
            https://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx
            
            Additionally, Path.GetInvalidPathChars() doesn't include "?" or "*" which are invalid characters,
            and Path.GetInvalidFileNameChars() includes ":" and "\" which are valid characters.
            
            The more accurate way is to let the framework parse the path and throw on any errors.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.NormalizeWithForwardSlash(System.String)">
            <summary>
            If the current environment uses the '\' directory separator, replaces all uses of '\'
            in the given string with '/'. Otherwise, returns the string.
            </summary>
            <remarks>
            This method is equivalent to Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig.NormalizeWithForwardSlash
            Both methods should be kept in sync.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ReflectionUtilities.GetTypeFromEither(System.String,System.String)">
            <summary>
            Find a <see cref="T:System.Type"/> instance by first probing the contract name and then the name as it
            would exist in mscorlib.  This helps satisfy both the CoreCLR and Desktop scenarios. 
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.UnicodeCharacterUtilities">
            <summary>
            Defines a set of helper methods to classify Unicode characters.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid Unicode identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="T:Roslyn.Utilities.AnnotationTable`1">
            <summary>
            An AnnotationTable helps you attach your own annotation types/instances to syntax.  
            
            It maintains a map between your instances and actual SyntaxAnnotation's used to annotate the nodes
            and offers an API that matches the true annotation API on SyntaxNode.
            
            The table controls the lifetime of when you can find and retrieve your annotations. You won't be able to 
            find your annotations via HasAnnotations/GetAnnotations unless you use the same annotation table for these operations
            that you used for the WithAdditionalAnnotations operation.  
            
            Your custom annotations are not serialized with the syntax tree, so they won't move across boundaries unless the 
            same AnnotationTable is available on both ends.
            
            also, note that this table is not thread safe.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1">
            <summary>
            Represents a value that can be retrieved synchronously or asynchronously by many clients.
            The value will be computed on-demand the moment the first client asks for it. While being
            computed, more clients can request the value. As long as there are outstanding clients the
            underlying computation will proceed.  If all outstanding clients cancel their request then
            the underlying value computation will be cancelled as well.
            
            Creators of an <see cref="T:Roslyn.Utilities.AsyncLazy`1" /> can specify whether the result of the computation is
            cached for future requests or not. Choosing to not cache means the computation functions are kept
            alive, whereas caching means the value (but not functions) are kept alive once complete.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._asynchronousComputeFunction">
            <summary>
            The underlying function that starts an asynchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it.  Otherwise,
            it is kept around in case the value needs to be computed again.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._synchronousComputeFunction">
            <summary>
            The underlying function that starts a synchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it, or if we
            didn't get any synchronous function given to us in the first place.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._cacheResult">
            <summary>
            Whether or not we should keep the value around once we've computed it.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._cachedResult">
            <summary>
            The Task that holds the cached result.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.s_gate">
            <summary>
            Mutex used to protect reading and writing to all mutable objects and fields.  Traces
            indicate that there's negligible contention on this lock, hence we can save some memory
            by using a single lock for all AsyncLazy instances.  Only trivial and non-reentrant work
            should be done while holding the lock.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._requests">
            <summary>
            The hash set of all currently outstanding asynchronous requests. Null if there are no requests,
            and will never be empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._asynchronousComputationCancellationSource">
            <summary>
            If an asynchronous request is active, the CancellationTokenSource that allows for
            cancelling the underlying computation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._computationActive">
            <summary>
            Whether a computation is active or queued on any thread, whether synchronous or
            asynchronous.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(`0)">
            <summary>
            Creates an AsyncLazy that always returns the value, analogous to <see cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{`0}},System.Func{System.Threading.CancellationToken,`0},System.Boolean)">
            <summary>
            Creates an AsyncLazy that supports both asynchronous computation and inline synchronous
            computation.
            </summary>
            <param name="asynchronousComputeFunction">A function called to start the asynchronous
            computation. This function should be cheap and non-blocking.</param>
            <param name="synchronousComputeFunction">A function to do the work synchronously, which
            is allowed to block. This function should not be implemented by a simple Wait on the
            asynchronous value. If that's all you are doing, just don't pass a synchronous function
            in the first place.</param>
            <param name="cacheResult">Whether the result should be cached once the computation is
            complete.</param>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.TakeLock(System.Threading.CancellationToken)">
            <summary>
            Takes the lock for this object and if acquired validates the invariants of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1.Request">
            <remarks>
            This inherits from <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> to avoid allocating two objects when we can just use one.
            The public surface area of <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> should probably be avoided in favor of the public
            methods on this class for correct behavior.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.Request._cancellationToken">
            <summary>
            The <see cref="T:System.Threading.CancellationToken"/> associated with this request. This field will be initialized before
            any cancellation is observed from the token.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.BKTree">
             <summary>
             NOTE: Only use if you truly need a BK-tree.  If you just want to compare words, use
             the 'SpellChecker' type instead.
            
             An implementation of a Burkhard-Keller tree.  Introduced in:
             
             'Some approaches to best-match file searching.'
             Communications of the ACM CACM
             Volume 16 Issue 4, April 1973 
             Pages 230-236 
             http://dl.acm.org/citation.cfm?doid=362003.362025
             </summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Edge.ChildNodeIndex">
            <summary>Where the child node can be found in <see cref="F:Roslyn.Utilities.BKTree._nodes"/>.</summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.WordSpan">
            <summary>
            The string this node corresponds to.  Specifically, this span is the range of
            <see cref="F:Roslyn.Utilities.BKTree._concatenatedLowerCaseWords"/> for that string.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.EdgeCount">
            <summary>How many child edges this node has.</summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.FirstEdgeIndex">
            <summary>Where the first edge can be found in <see cref="F:Roslyn.Utilities.BKTree._edges"/>.  The edges 
            are in the range _edges[FirstEdgeIndex, FirstEdgeIndex + EdgeCount)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.EditDistance">
            <summary>
             NOTE: Only use if you truly need an edit distance.  If you just want to compare words, use
             the 'SpellChecker' type instead.
            
             Implementation of the Damerau-Levenshtein edit distance algorithm from:
             An Extension of the String-to-String Correction Problem:
             Published in Journal of the ACM (JACM)
             Volume 22 Issue 2, April 1975.
            
             Important, unlike many edit distance algorithms out there, this one implements a true metric
             that satisfies the triangle inequality.  (Unlike the "Optimal String Alignment" or "Restricted
             string edit distance" solutions which do not).  This means this edit distance can be used in
             other domains that require the triangle inequality (like BKTrees).
            
             Specifically, this implementation satisfies the following inequality: D(x, y) + D(y, z) >= D(x, z)
             (where D is the edit distance).
            </summary> 
        </member>
        <member name="M:Roslyn.Utilities.IDictionaryExtensions.MultiRemoveSet``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)">
            <summary>
            Private implementation we can delegate to for sets.
            This must be a different name as overloads are not resolved based on constraints
            and would conflict with <see cref="M:Roslyn.Utilities.IDictionaryExtensions.MultiRemove``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)"/>
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.IReferenceCountedDisposable`1">
            <summary>
            A covariant interface form of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> that lets you re-cast an <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/>
            to a more base type. This can include types that do not implement <see cref="T:System.IDisposable"/> if you want to prevent a caller from accidentally
            disposing <see cref="P:Roslyn.Utilities.IReferenceCountedDisposable`1.Target"/> directly.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Roslyn.Utilities.IReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:System.IDisposable.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:System.IDisposable.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:System.IDisposable.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:System.IDisposable.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Roslyn.Utilities.IReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:Roslyn.Utilities.LazyInitialization.EnsureInitialized``1(``0@,System.Func{``0})">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.LazyInitialization.EnsureInitialized``2(``0@,System.Func{``1,``0},``1)">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <typeparam name="U">The type of the <paramref name="state"/> argument passed to the value factory.</typeparam>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <param name="state">An argument passed to the value factory.</param>
            <returns>The target value.</returns>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock">
            <summary>
            A lightweight mutual exclusion object which supports waiting with cancellation and prevents
            recursion (i.e. you may not call Wait if you already hold the lock)
            </summary>
            <remarks>
            <para>
            The <see cref="T:Roslyn.Utilities.NonReentrantLock"/> provides a lightweight mutual exclusion class that doesn't
            use Windows kernel synchronization primitives.
            </para>
            <para>
            The implementation is distilled from the workings of <see cref="T:System.Threading.SemaphoreSlim"/>
            The basic idea is that we use a regular sync object (Monitor.Enter/Exit) to guard the setting
            of an 'owning thread' field. If, during the Wait, we find the lock is held by someone else
            then we register a cancellation callback and enter a "Monitor.Wait" loop. If the cancellation
            callback fires, then it "pulses" all the waiters to wake them up and check for cancellation.
            Waiters are also "pulsed" when leaving the lock.
            </para>
            <para>
            All public members of <see cref="T:Roslyn.Utilities.NonReentrantLock"/> are thread-safe and may be used concurrently
            from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._syncLock">
            <summary>
            A synchronization object to protect access to the <see cref="F:Roslyn.Utilities.NonReentrantLock._owningThreadId"/> field and to be pulsed
            when <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/> is called and during cancellation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._owningThreadId">
            <summary>
            The <see cref="P:System.Environment.CurrentManagedThreadId" /> of the thread that holds the lock. Zero if no thread is holding
            the lock.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="useThisInstanceForSynchronization">If false (the default), then the class
            allocates an internal object to be used as a sync lock.
            If true, then the sync lock object will be the NonReentrantLock instance itself. This
            saves an allocation but a client may not safely further use this instance in a call to
            Monitor.Enter/Exit or in a "lock" statement.
            </param>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.Factory">
            <summary>
            Shared factory for use in lazy initialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:Roslyn.Utilities.NonReentrantLock"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <remarks>
            Recursive locking is not supported. i.e. A thread may not call Wait successfully twice without an
            intervening <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/>.
            </remarks>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <exception cref="T:System.Threading.LockRecursionException">The caller already holds the lock</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Release">
            <summary>
            Exit the mutual exclusion.
            </summary>
            <remarks>
            The calling thread must currently hold the lock.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.LockHeldByMe">
            <summary>
            Determine if the lock is currently held by the calling thread.
            </summary>
            <returns>True if the lock is currently held by the calling thread.</returns>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.AssertHasLock">
            <summary>
            Throw an exception if the lock is not held by the calling thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsLocked">
            <summary>
            Checks if the lock is currently held.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsOwnedByMe">
            <summary>
            Checks if the lock is currently held by the calling thread.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.TakeOwnership">
            <summary>
            Take ownership of the lock (by the calling thread). The lock may not already
            be held by any other code.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.ReleaseOwnership">
            <summary>
            Release ownership of the lock. The lock must already be held by the calling thread.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.s_cancellationTokenCanceledEventHandler">
            <summary>
            Action object passed to a cancellation token registration.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.CancellationTokenCanceledEventHandler(System.Object)">
            <summary>
            Callback executed when a cancellation token is canceled during a Wait.
            </summary>
            <param name="obj">The syncLock that protects a <see cref="T:Roslyn.Utilities.NonReentrantLock"/> instance.</param>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock.SemaphoreDisposer">
            <summary>
            Since we want to avoid boxing the return from <see cref="M:Roslyn.Utilities.NonReentrantLock.DisposableWait(System.Threading.CancellationToken)"/>, this type must be public.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ImmutableHashMapExtensions.GetOrAdd``3(Roslyn.Collections.Immutable.ImmutableHashMap{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Obtains the value for the specified key from a dictionary, or adds a new value to the dictionary where the key did not previously exist.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument supplied to the value factory.</typeparam>
            <param name="location">The variable or field to atomically update if the specified <paramref name="key" /> is not in the dictionary.</param>
            <param name="key">The key for the value to retrieve or add.</param>
            <param name="valueFactory">The function to execute to obtain the value to insert into the dictionary if the key is not found.</param>
            <param name="factoryArgument">The argument to pass to the value factory.</param>
            <returns>The value obtained from the dictionary or <paramref name="valueFactory" /> if it was not present.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1">
             <summary>
             A reference-counting wrapper which allows multiple uses of a single disposable object in code, which is
             deterministically released (by calling <see cref="M:System.IDisposable.Dispose"/>) when the last reference is
             disposed.
             </summary>
             <remarks>
             <para>Each instance of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> represents a counted reference (also
             referred to as a <em>reference</em> in the following documentation) to a target object. Each of these
             references has a lifetime, starting when it is constructed and continuing through its release. During
             this time, the reference is considered <em>alive</em>. Each reference which is alive owns exactly one
             reference to the target object, ensuring that it will not be disposed while still in use. A reference is
             released through either of the following actions:</para>
            
             <list type="bullet">
             <item>The reference is explicitly released by a call to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>.</item>
             <item>The reference is no longer in use by managed code and gets reclaimed by the garbage collector.</item>
             </list>
            
             <para>While each instance of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> should be explicitly disposed when
             the object is no longer needed by the code owning the reference, this implementation will not leak resources
             in the event one or more callers fail to do so. When all references to an object are explicitly released
             (i.e. by calling <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>), the target object will itself be deterministically released by a
             call to <see cref="M:System.IDisposable.Dispose"/> when the last reference to it is released. However, in the event
             one or more references is not explicitly released, the underlying object will still become eligible for
             non-deterministic release (i.e. finalization) as soon as each reference to it is released by one of the
             two actions described previously.</para>
            
             <para>When using <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/>, certain steps must be taken to ensure the
             target object is not disposed early.</para>
            
             <list type="number">
             <para>Use <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> consistently. In other words, do not mix code using
             reference-counted wrappers with code that references to the target directly.</para>
             <para>Only use the <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.#ctor(`0)"/> constructor one time per target object.
             Additional references to the same target object must only be obtained by calling
             <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/>.</para>
             <para>Do not call <see cref="M:System.IDisposable.Dispose"/> on the target object directly. It will be called
             automatically at the appropriate time, as described above.</para>
             </list>
            
             <para>All public methods on this type adhere to their pre- and post-conditions and will not invalidate state
             even in concurrent execution.</para>
             </remarks>
             <typeparam name="T">The type of disposable object.</typeparam>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1._instance">
            <summary>
            The target of this reference. This value is initialized to a non-<see langword="null"/> value in the
            constructor, and set to <see langword="null"/> when the current reference is disposed.
            </summary>
            <remarks>
            <para>This value is only cleared in order to support cases where one or more references is garbage
            collected without having <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> called.</para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1._boxedReferenceCount">
             <summary>
             The boxed reference count, which is shared by all references with the same <see cref="P:Roslyn.Utilities.ReferenceCountedDisposable`1.Target"/> object.
             </summary>
             <remarks>
             <para>This field serves as the synchronization object for the current type, since it is shared among all
             counted reference to the same target object. Accesses to <see cref="F:System.Runtime.CompilerServices.StrongBox`1.Value"/> should only
             occur when this object is locked.</para>
            
             <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
             available in source control history. The use of exclusive locks was not causing any measurable
             performance overhead even on 28-thread machines at the time this was written.</para>
             </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.#ctor(`0)">
            <summary>
            Initializes a new reference counting wrapper around an <see cref="T:System.IDisposable"/> object.
            </summary>
            <remarks>
            <para>The reference count is initialized to 1.</para>
            </remarks>
            <param name="instance">The object owned by this wrapper.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="instance"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:Roslyn.Utilities.ReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReferenceImpl(`0,System.Runtime.CompilerServices.StrongBox{System.Int32})">
            <summary>
            Provides the implementation for <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/> and
            <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference.TryAddReference"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose">
            <summary>
            Releases the current reference, causing the underlying object to be disposed if this was the last
            reference.
            </summary>
            <remarks>
            <para>After this instance is disposed, the <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/> method can no longer be used to
            object a new reference to the target, even if other references to the target object are still in
            use.</para>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference">
            <summary>
            Represents a weak reference to a <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> which is capable of
            obtaining a new counted reference up until the point when the object is no longer accessible.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference._weakInstance">
            <summary>
            DO NOT DISPOSE OF THE TARGET.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference.TryAddReference">
             <summary>
             Increments the reference count for the disposable object, and returns a new disposable reference to
             it.
             </summary>
             <remarks>
             <para>Unlike <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/>, this method is capable of
             adding a reference to the underlying instance all the way up to the point where it is finally
             disposed.</para>
            
             <para>The returned object is an independent reference to the same underlying object. Disposing of
             the returned value multiple times will only cause the reference count to be decreased once.</para>
             </remarks>
             <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object,
             if it has not yet been disposed; otherwise, <see langword="null"/> if the underlying object has
             already been disposed.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposableCache`2">
            <summary>
            Implements a reference-counted cache, where key/value pairs are associated with a count. When the count of a pair goes to zero,
            the value is evicted. Values can also be explicitly evicted at any time. In that case, any new calls to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposableCache`2.GetOrCreate``1(`0,System.Func{`0,``0,`1},``0)"/>
            will return a new value, and the existing holders of the evicted value will still dispose it once they're done with it.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SemaphoreSlimFactory">
            <summary>
            Container for a <see cref="T:System.Threading.SemaphoreSlim"/> factory.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SemaphoreSlimFactory.Instance">
            <summary>
            Factory object that may be used for lazy initialization. Creates AsyncSemaphore instances with an initial count of 1.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SoftCrashException">
            <summary>
            TODO: remove this exception: https://github.com/dotnet/roslyn/issues/40476
            
            this represents soft crash request compared to hard crash which will bring down VS.
            
            by soft crash, it means everything same as hard crash except it should use NFW and info bar
            to inform users about unexpected condition instead of killing VS as traditional crash did.
            
            in other words, no one should ever try to recover from this exception. but they must try to not hard crash.
            
            this exception is based on cancellation exception since, in Roslyn code, cancellation exception is so far
            only safest exception to throw without worrying about crashing VS 99%. there is still 1% case it will bring
            down VS and those places should be guarded on this exception as we find such place.
            
            for now, this is an opt-in based. if a feature wants to move to soft crash (ex, OOP), one should catch
            exception and translate that to this exception and then add handler which report NFW and info bar in their
            code path and make sure it doesn't bring down VS.
            
            as we use soft-crash in more places, we should come up with more general framework.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.WordSimilarityChecker._substringsAreSimilar">
            <summary>
            Whether or words should be considered similar if one is contained within the other
            (regardless of edit distance).  For example if is true then IService would be considered
            similar to IServiceFactory despite the edit distance being quite high at 7.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WordSimilarityChecker.AreSimilar(System.String,System.String,System.Boolean,System.Double@)">
            <summary>
            Returns true if 'originalText' and 'candidateText' are likely a misspelling of each other.
            Returns false otherwise.  If it is a likely misspelling a similarityWeight is provided
            to help rank the match.  Lower costs mean it was a better match.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SyntaxPath">
            <summary>
            Stores the "path" from the root of a tree to a node, allowing the node to be recovered in a
            later snapshot of the tree, under certain circumstances.
            
            The implementation stores the child indices to represent the path, so any edit which affects
            the child indices could render this object unable to recover its node.  NOTE: One thing C#
            IDE has done in the past to do a better job of this is to store the fully qualified name of
            the member to at least be able to descend into the same member.  We could apply the same sort
            of logic here.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SyntaxPath.TryResolve(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNodeOrToken@)">
            <summary>
            Attempts to recover the node at this path in the provided tree.  If the node is found
            then 'true' is returned, otherwise the result is 'false' and 'node' will be null.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConstantValueSource`1">
            <summary>
            This value source keeps a strong reference to a value.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ValueSource`1">
            <summary>
            A class that abstracts the accessing of a value that is guaranteed to be available at some point.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.WeakValueSource`1">
            <summary>
            A <see cref="T:Roslyn.Utilities.ValueSource`1"/> that keeps a weak reference to a value.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.VoidResult">
            <summary>
            Explicitly indicates result is void
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WeakEventHandler`1.Create``1(``0,System.Action{``0,System.Object,`0})">
            <summary>
            Creates an event handler that holds onto the target weakly.
            </summary>
            <param name="target">The target that is held weakly, and passed as an argument to the invoker.</param>
            <param name="invoker">An action that will receive the event arguments as well as the target instance. 
            The invoker itself must not capture any state.</param>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
        <member name="T:Roslyn.Collections.Immutable.ImmutableHashMap`2">
            <summary>
            An immutable unordered hash map implementation.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2._root">
            <summary>
            The root node of the tree that stores this map.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2._keyComparer">
            <summary>
            The comparer used to sort keys in this map.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2._valueComparer">
            <summary>
            The comparer used to detect equivalent values in this map.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.Bucket,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> class.
            </summary>
            <param name="root">The root.</param>
            <param name="comparer">The comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> class.
            </summary>
            <param name="comparer">The comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Empty">
            <summary>
            Gets an empty map with default equality comparers.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Clear">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Add(`0,`1)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.SetItem(`0,`1)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Remove(`0)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Returns a hash map that uses the specified key and value comparers and has the same contents as this map.
            </summary>
            <param name="keyComparer">The key comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <param name="valueComparer">The value comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <returns>The hash map with the new comparers.</returns>
            <remarks>
            In the event that a change in the key equality comparer results in a key collision, an exception is thrown.
            </remarks>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns a hash map that uses the specified key comparer and current value comparer and has the same contents as this map.
            </summary>
            <param name="keyComparer">The key comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <returns>The hash map with the new comparers.</returns>
            <remarks>
            In the event that a change in the key equality comparer results in a key collision, an exception is thrown.
            </remarks>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Count">
            <summary>
            Gets the number of elements in this collection.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Keys">
            <summary>
            Gets the keys in the map.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Values">
            <summary>
            Gets the values in the map.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Item(`0)">
            <summary>
            Gets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
              <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether this map contains the specified key-value pair.
            </summary>
            <param name="keyValuePair">The key value pair.</param>
            <returns>
              <c>true</c> if this map contains the key-value pair; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryGetValue(`0,`1@)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryExchangeKey(`0,`0@)">
            <summary>
            Exchanges a key for the actual key instance found in this map.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="existingKey">Receives the equal key found in the map.</param>
            <returns>A value indicating whether an equal and existing key was found in the map.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryCastToImmutableMap(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}@)">
            <summary>
            Attempts to discover an <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> instance beneath some enumerable sequence
            if one exists.
            </summary>
            <param name="sequence">The sequence that may have come from an immutable map.</param>
            <param name="other">Receives the concrete <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> typed value if one can be found.</param>
            <returns><c>true</c> if the cast was successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean,System.Boolean)">
            <summary>
            Bulk adds entries to the map.
            </summary>
            <param name="pairs">The entries to add.</param>
            <param name="overwriteOnCollision"><c>true</c> to allow the <paramref name="pairs"/> sequence to include duplicate keys and let the last one win; <c>false</c> to throw on collisions.</param>
            <param name="avoidToHashMap"><c>true</c> when being called from ToHashMap to avoid StackOverflow.</param>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket.Hash">
            <summary>
            The hash for this bucket.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket"/> class.
            </summary>
            <param name="hash">The hash.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueBucket.#ctor(`0,`1,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueBucket"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="hashcode">The hashcode.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ListBucket.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueBucket[])">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ListBucket"/> class.
            </summary>
            <param name="buckets">The buckets.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket.#ctor(System.Int32,System.UInt32,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.Bucket[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket"/> class.
            </summary>
            <param name="hashRoll">The hash roll.</param>
            <param name="used">The used.</param>
            <param name="buckets">The buckets.</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket.#ctor(System.Int32,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueOrListBucket,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueOrListBucket)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket"/> class.
            </summary>
            <param name="suggestedHashRoll">The suggested hash roll.</param>
            <param name="bucket1">The bucket1.</param>
            <param name="bucket2">The bucket2.</param>
        </member>
        <member name="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy._map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1})">
            <summary>   
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>
            Declare the following extension methods in System.Linq namespace to avoid accidental boxing of ImmutableArray{T} that implements IEnumerable{T}.
            The boxing would occur if the methods were defined in Roslyn.Utilities and the file calling these methods has <c>using Roslyn.Utilities</c>
            but not <c>using System.Linq</c>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.Text.Rune">
            <summary>
            Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive).
            </summary>
            <remarks>
            This type's constructors and conversion operators validate the input, so consumers can call the APIs
            assuming that the underlying <see cref="T:System.Text.Rune"/> instance is well-formed.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Char)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided UTF-16 code unit.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="ch"/> represents a UTF-16 surrogate code point
            U+D800..U+DFFF, inclusive.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Char,System.Char)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided UTF-16 surrogate pair.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="highSurrogate"/> does not represent a UTF-16 high surrogate code point
            or <paramref name="lowSurrogate"/> does not represent a UTF-16 low surrogate code point.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided Unicode scalar value.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="value"/> does not represent a value Unicode scalar value.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.UInt32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided Unicode scalar value.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="value"/> does not represent a value Unicode scalar value.
            </exception>
        </member>
        <member name="P:System.Text.Rune.IsAscii">
            <summary>
            Returns true if and only if this scalar value is ASCII ([ U+0000..U+007F ])
            and therefore representable by a single UTF-8 code unit.
            </summary>
        </member>
        <member name="P:System.Text.Rune.IsBmp">
            <summary>
            Returns true if and only if this scalar value is within the BMP ([ U+0000..U+FFFF ])
            and therefore representable by a single UTF-16 code unit.
            </summary>
        </member>
        <member name="P:System.Text.Rune.Plane">
            <summary>
            Returns the Unicode plane (0 to 16, inclusive) which contains this scalar.
            </summary>
        </member>
        <member name="P:System.Text.Rune.ReplacementChar">
            <summary>
            A <see cref="T:System.Text.Rune"/> instance that represents the Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="P:System.Text.Rune.Utf16SequenceLength">
            <summary>
            Returns the length in code units (<see cref="T:System.Char"/>) of the
            UTF-16 sequence required to represent this scalar value.
            </summary>
            <remarks>
            The return value will be 1 or 2.
            </remarks>
        </member>
        <member name="P:System.Text.Rune.Utf8SequenceLength">
            <summary>
            Returns the length in code units of the
            UTF-8 sequence required to represent this scalar value.
            </summary>
            <remarks>
            The return value will be 1 through 4, inclusive.
            </remarks>
        </member>
        <member name="P:System.Text.Rune.Value">
            <summary>
            Returns the Unicode scalar value as an integer.
            </summary>
        </member>
        <member name="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the beginning of the provided UTF-16 source buffer.
            </summary>
            <returns>
            <para>
            If the source buffer begins with a valid UTF-16 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.Done"/>,
            and outs via <paramref name="result"/> the decoded <see cref="T:System.Text.Rune"/> and via <paramref name="charsConsumed"/> the
            number of <see langword="char"/>s used in the input buffer to encode the <see cref="T:System.Text.Rune"/>.
            </para>
            <para>
            If the source buffer is empty or contains only a standalone UTF-16 high surrogate character, returns <see cref="F:System.Buffers.OperationStatus.NeedMoreData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="charsConsumed"/> the length of the input buffer.
            </para>
            <para>
            If the source buffer begins with an ill-formed UTF-16 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.InvalidData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="charsConsumed"/> the number of
            <see langword="char"/>s used in the input buffer to encode the ill-formed sequence.
            </para>
            </returns>
            <remarks>
            The general calling convention is to call this method in a loop, slicing the <paramref name="source"/> buffer by
            <paramref name="charsConsumed"/> elements on each iteration of the loop. On each iteration of the loop <paramref name="result"/>
            will contain the real scalar value if successfully decoded, or it will contain <see cref="P:System.Text.Rune.ReplacementChar"/> if
            the data could not be successfully decoded. This pattern provides convenient automatic U+FFFD substitution of
            invalid sequences while iterating through the loop.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the beginning of the provided UTF-8 source buffer.
            </summary>
            <returns>
            <para>
            If the source buffer begins with a valid UTF-8 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.Done"/>,
            and outs via <paramref name="result"/> the decoded <see cref="T:System.Text.Rune"/> and via <paramref name="bytesConsumed"/> the
            number of <see langword="byte"/>s used in the input buffer to encode the <see cref="T:System.Text.Rune"/>.
            </para>
            <para>
            If the source buffer is empty or contains only a partial UTF-8 subsequence, returns <see cref="F:System.Buffers.OperationStatus.NeedMoreData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="bytesConsumed"/> the length of the input buffer.
            </para>
            <para>
            If the source buffer begins with an ill-formed UTF-8 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.InvalidData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="bytesConsumed"/> the number of
            <see langword="char"/>s used in the input buffer to encode the ill-formed sequence.
            </para>
            </returns>
            <remarks>
            The general calling convention is to call this method in a loop, slicing the <paramref name="source"/> buffer by
            <paramref name="bytesConsumed"/> elements on each iteration of the loop. On each iteration of the loop <paramref name="result"/>
            will contain the real scalar value if successfully decoded, or it will contain <see cref="P:System.Text.Rune.ReplacementChar"/> if
            the data could not be successfully decoded. This pattern provides convenient automatic U+FFFD substitution of
            invalid sequences while iterating through the loop.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the end of the provided UTF-16 source buffer.
            </summary>
            <remarks>
            This method is very similar to <see cref="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)"/>, but it allows
            the caller to loop backward instead of forward. The typical calling convention is that on each iteration
            of the loop, the caller should slice off the final <paramref name="charsConsumed"/> elements of
            the <paramref name="source"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the end of the provided UTF-8 source buffer.
            </summary>
            <remarks>
            This method is very similar to <see cref="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)"/>, but it allows
            the caller to loop backward instead of forward. The typical calling convention is that on each iteration
            of the loop, the caller should slice off the final <paramref name="bytesConsumed"/> elements of
            the <paramref name="source"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-16 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-16.</param>
            <returns>The number of <see cref="T:System.Char"/>s written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="destination"/> is not large enough to hold the output.
            </exception>
        </member>
        <member name="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-8 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-8.</param>
            <returns>The number of <see cref="T:System.Byte"/>s written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="destination"/> is not large enough to hold the output.
            </exception>
        </member>
        <member name="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Text.Rune"/> which begins at index <paramref name="index"/> in
            string <paramref name="input"/>.
            </summary>
            <remarks>
            Throws if <paramref name="input"/> is null, if <paramref name="index"/> is out of range, or
            if <paramref name="index"/> does not reference the start of a valid scalar value within <paramref name="input"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.IsValid(System.Int32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Rune.IsValid(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Rune.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation of this <see cref="T:System.Text.Rune"/> instance.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided UTF-16 surrogate pair.
            Returns <see langword="false"/> if the input values don't represent a well-formed UTF-16surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-16 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-16.</param>
            <param name="charsWritten">
            The number of <see cref="T:System.Char"/>s written to <paramref name="destination"/>,
            or 0 if the destination buffer is not large enough to contain the output.</param>
            <returns>True if the value was written to the buffer; otherwise, false.</returns>
            <remarks>
            The <see cref="P:System.Text.Rune.Utf16SequenceLength"/> property can be queried ahead of time to determine
            the required size of the <paramref name="destination"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a destination buffer as UTF-8 bytes.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-8.</param>
            <param name="bytesWritten">
            The number of <see cref="T:System.Byte"/>s written to <paramref name="destination"/>,
            or 0 if the destination buffer is not large enough to contain the output.</param>
            <returns>True if the value was written to the buffer; otherwise, false.</returns>
            <remarks>
            The <see cref="P:System.Text.Rune.Utf8SequenceLength"/> property can be queried ahead of time to determine
            the required size of the <paramref name="destination"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)">
            <summary>
            Attempts to get the <see cref="T:System.Text.Rune"/> which begins at index <paramref name="index"/> in
            string <paramref name="input"/>.
            </summary>
            <returns><see langword="true"/> if a scalar value was successfully extracted from the specified index,
            <see langword="false"/> if a value could not be extracted due to invalid data.</returns>
            <remarks>
            Throws only if <paramref name="input"/> is null or <paramref name="index"/> is out of range.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.UnsafeCreate(System.UInt32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> without performing validation on the input.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeDebug.ToHexString(System.UInt32)">
            <summary>
            Formats a code point as the hex string "U+XXXX".
            </summary>
            <remarks>
            The input value doesn't have to be a real code point in the Unicode codespace. It can be any integer.
            </remarks>
        </member>
        <member name="F:System.Text.UnicodeUtility.ReplacementChar">
            <summary>
            The Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetPlane(System.UInt32)">
            <summary>
            Returns the Unicode plane (0 through 16, inclusive) which contains this code point.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetScalarFromUtf16SurrogatePair(System.UInt32,System.UInt32)">
            <summary>
            Returns a Unicode scalar value from two code points representing a UTF-16 surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf16SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-16 code units required to represent this value.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf16SurrogatesFromSupplementaryPlaneScalar(System.UInt32,System.Char@,System.Char@)">
            <summary>
            Decomposes an astral Unicode scalar into UTF-16 high and low surrogate code units.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf8SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-8 code units required to represent this value.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsAsciiCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is an ASCII
            character ([ U+0000..U+007F ]).
            </summary>
            <remarks>
            Per http://www.unicode.org/glossary/#ASCII, ASCII is only U+0000..U+007F.
            </remarks>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsBmpCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is in the
            Basic Multilingual Plane (BMP).
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsHighSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 high surrogate code point,
            i.e., is in [ U+D800..U+DBFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsInRangeInclusive(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsLowSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 low surrogate code point,
            i.e., is in [ U+DC00..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 surrogate code point,
            i.e., is in [ U+D800..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsValidCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="codePoint"/> is a valid Unicode code
            point, i.e., is in [ U+0000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsValidUnicodeScalar(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.AllCharsInUInt32AreAscii(System.UInt32)">
            <summary>
            Returns true iff the UInt32 represents two ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.AllCharsInUInt64AreAscii(System.UInt64)">
            <summary>
            Returns true iff the UInt64 represents four ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.ConvertAllAsciiCharsInUInt32ToLowercase(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns the invariant
            lowercase representation of those characters. Requires the input value to contain
            two ASCII UTF-16 characters in machine endianness.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.ConvertAllAsciiCharsInUInt32ToUppercase(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns the invariant
            uppercase representation of those characters. Requires the input value to contain
            two ASCII UTF-16 characters in machine endianness.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32ContainsAnyLowercaseAsciiChar(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns true iff
            the input contains one or more lowercase ASCII characters.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32ContainsAnyUppercaseAsciiChar(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns true iff
            the input contains one or more uppercase ASCII characters.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32OrdinalIgnoreCaseAscii(System.UInt32,System.UInt32)">
            <summary>
            Given two UInt32s that represent two ASCII UTF-16 characters each, returns true iff
            the two inputs are equal using an ordinal case-insensitive comparison.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt64OrdinalIgnoreCaseAscii(System.UInt64,System.UInt64)">
            <summary>
            Given two UInt64s that represent four ASCII UTF-16 characters each, returns true iff
            the two inputs are equal using an ordinal case-insensitive comparison.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
    </members>
</doc>
